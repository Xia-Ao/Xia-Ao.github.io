<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数组排序算法.md | 夏夏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言以前对于排序，只知道冒泡排序，了解一点快速排序，一直是我的弱点，今天是时候好好攻克一下了参考：JS中可能用得到的全部的排序算法 时间复杂度 1、冒泡排序冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环,">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="数组排序算法.md">
<meta property="og:url" content="http://yoursite.com/2018/03/12/JS-数组排序算法/index.html">
<meta property="og:site_name" content="夏夏">
<meta property="og:description" content="前言以前对于排序，只知道冒泡排序，了解一点快速排序，一直是我的弱点，今天是时候好好攻克一下了参考：JS中可能用得到的全部的排序算法 时间复杂度 1、冒泡排序冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环,">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/assets/time.png">
<meta property="og:image" content="http://yoursite.com/assets/sort05.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort5_1.png">
<meta property="og:image" content="http://yoursite.com/assets/sort06.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort6_1.png">
<meta property="og:image" content="http://yoursite.com/assets/sort07.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort04.png">
<meta property="og:image" content="http://yoursite.com/assets/sort09.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort9_1.png">
<meta property="og:image" content="http://yoursite.com/assets/sort08.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort8_1.png">
<meta property="og:image" content="http://yoursite.com/assets/sort10.gif">
<meta property="og:image" content="http://yoursite.com/assets/sort12.png">
<meta property="og:updated_time" content="2018-04-05T14:49:33.524Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数组排序算法.md">
<meta name="twitter:description" content="前言以前对于排序，只知道冒泡排序，了解一点快速排序，一直是我的弱点，今天是时候好好攻克一下了参考：JS中可能用得到的全部的排序算法 时间复杂度 1、冒泡排序冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环,">
<meta name="twitter:image" content="http://yoursite.com/assets/time.png">
  
    <link rel="alternate" href="/atom.xml" title="夏夏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">夏夏</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">档案</a>
        
          <a class="main-nav-link" href="/tags">分类</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JS-数组排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/12/JS-数组排序算法/" class="article-date">
  <time datetime="2018-03-12T12:18:40.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数组排序算法.md
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前对于排序，只知道冒泡排序，了解一点快速排序，一直是我的弱点，今天是时候好好攻克一下了<br>参考：<a href="http://louiszhai.github.io/2016/12/23/sort/#冒泡排序" target="_blank" rel="noopener">JS中可能用得到的全部的排序算法</a></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="/assets/time.png" alt=""></p>
<h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.<br><img src="/assets/sort05.gif" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换下标a、b对应的数组数值，此方法抽离处理，后面直接使用，不做说明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exchange</span>(<span class="params">a, b, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = obj[a];</span><br><span class="line">    obj[a] = obj[b];</span><br><span class="line">    obj[b] = temp;</span><br><span class="line"><span class="comment">//        return obj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">                count++</span><br><span class="line">                exchange(i, j, array)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//count=81</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/sort5_1.png" alt=""></p>
<h3 id="2、双向冒泡排序"><a href="#2、双向冒泡排序" class="headerlink" title="2、双向冒泡排序"></a>2、双向冒泡排序</h3><p>双向冒泡排序是冒泡排序的一个简易升级版, 又称鸡尾酒排序. 冒泡排序是从低到高(或者从高到低)单向排序, 双向冒泡排序顾名思义就是从两个方向分别排序(通常, 先从低到高, 然后从高到低). 因此它比冒泡排序性能稍好一些.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">                exchange(i, j, array)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;  <span class="comment">//从一个方向开始循环检查</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[k])&#123;</span><br><span class="line"></span><br><span class="line">                exchange(i, k, array)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  count=81</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h3><p>从算法逻辑上看, 选择排序是一种简单且直观的排序算法. 它也是两层循环. 内层循环就像工人一样, 它是真正做事情的, 内层循环每执行一遍, 将选出本次待排序的元素中最小(或最大)的一个, 存放在数组的起始位置. 而 外层循环则像老板一样, 它告诉内层循环你需要不停的工作, 直到工作完成(也就是全部的元素排序完成).<br><em><strong>Tips</strong></em><br>: 选择排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 比如数组[2,2,1,3], 正向排序时, 第一个数字2将与数字1交换, 那么两个数字2之间的顺序将和原来的顺序不一致,<strong>虽然它们的值相同, 但它们相对的顺序却发生了变化</strong>. 我们将这种现象称作<code>不稳定性</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 3、选择排序 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = array.length; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">//由于第一个开始跟后面对比，因此只需要对比n-1</span></span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[min] &gt; array[j]) &#123;</span><br><span class="line">                min = j  <span class="comment">//每一轮循环记下此轮最小值的下标，在后面将此下标值放到数列前面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(min, i, array)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/sort06.gif" alt=""></p>
<p><img src="/assets/sort6_1.png" alt=""></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的设计初衷是往有序的数组中快速插入一个新的元素. 它的算法思想是: 把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p>
<p>插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 .</p>
<h3 id="4、直接插入排序"><a href="#4、直接插入排序" class="headerlink" title="4、直接插入排序"></a>4、直接插入排序</h3><p>它的基本思想是: 将待排序的元素按照大小顺序, 依次插入到一个已经排好序的数组之中, 直到所有的元素都插入进去.<br>由于直接插入排序每次只移动一个元素的位置, 并不会改变值相同的元素之间的排序, 因此它是一种稳定排序.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 4、直接插入排序 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = array.length; i &lt; len; i++) &#123; <span class="comment">//直接从第二个开始比较</span></span><br><span class="line">        <span class="keyword">let</span> current = array[i];  <span class="comment">//将这次要比较的值存储起来，作为这一轮循环里面的常量</span></span><br><span class="line">        <span class="keyword">let</span> index = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从index前一位数开始比较比较，如果当前比较的数小于它的前一位，则将大的数后移一位</span></span><br><span class="line">        <span class="keyword">while</span> (current &lt; array[index - <span class="number">1</span>] &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            array[index] = array[index - <span class="number">1</span>];</span><br><span class="line">            index--;  <span class="comment">//于此同时，下标也前移一位，继续下一次比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index !== i) &#123;  <span class="comment">//防止自己赋值给自己，</span></span><br><span class="line">            array[index] = current <span class="comment">//如果不是自己，则一定是之前后移空出来留给current的位置，插入进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/sort07.gif" alt=""></p>
<h3 id="5、折半插入排序"><a href="#5、折半插入排序" class="headerlink" title="5、折半插入排序"></a>5、折半插入排序</h3><p>折半插入排序是直接插入排序的升级版. 鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可.</p>
<p>说白一点就是从第二个数开始向前比较，前面的数（已经排好序）分成两半，找到中间的数，比较大小，然后在向中间循环，一直找到介于两者之间的，然后把之后的后移，将此值插入到后移留出来的位置。</p>
<p>和直接插入法相比，少了一半数据量的对比。</p>
<p>算法基本思想是:</p>
<ol>
<li>取0 ~ i-1的中间点( m = (i-1)&gt;&gt;1 ), array[i] 与 array[m] 进行比较, 若array[i] &lt; array[m] , 则说明待插入的元素array[i] 应该处于数组的 0 ~ m 索引之间; 反之, 则说明它应该处于数组的 m ~ i-1 索引之间.</li>
<li>重复步骤1, 每次缩小一半的查找范围, 直至找到插入的位置.</li>
<li>将数组中插入位置之后的元素全部后移一位.</li>
<li>在指定位置插入第 i 个元素.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 5、折半插入排序 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = array.length; i &lt; len; i++) &#123; <span class="comment">//直接从第二个开始比较 i=1</span></span><br><span class="line">        <span class="keyword">let</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>, current = array[i];</span><br><span class="line">        <span class="comment">//找中值对应的下标</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line"><span class="comment">//                let m = Math.floor((low+high) / 2);</span></span><br><span class="line">            <span class="keyword">let</span> m = (low + high) &gt;&gt; <span class="number">1</span>;   <span class="comment">//x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[m]) &#123;</span><br><span class="line">                high = m - <span class="number">1</span>   <span class="comment">//保证low&lt;=high顺利成立，将high定位低半区</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = m + <span class="number">1</span>     <span class="comment">//同理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将在要插入值位置之后的所有元素后移，留出插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; low; j--) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">console</span>.log(array)</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = current  <span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、希尔排序"><a href="#6、希尔排序" class="headerlink" title="6、希尔排序"></a>6、希尔排序</h3><p>希尔排序也称缩小增量排序, 它是直接插入排序的另外一个升级版, 实质就是分组插入排序. 希尔排序以其设计者希尔(Donald Shell)的名字命名, 并于1959年公布.</p>
<p>算法的基本思想:</p>
<ol>
<li>将数组拆分为若干个子分组, 每个分组由相距一定”增量”的元素组成. 比方说将[0,1,2,3,4,5,6,7,8,9,10]的数组拆分为”增量”为5的分组, 那么子分组分别为 [0,5], [1,6], [2,7], [3,8], [4,9] 和 [5,10].</li>
<li>然后对每个子分组应用直接插入排序.</li>
<li>逐步减小”增量”, 重复步骤1,2.</li>
<li>直至”增量”为1, 这是最后一个排序, 此时的排序, 也就是对全数组进行直接插入排序.</li>
</ol>
<p>示意图：<br><img src="/assets/sort04.png" alt=""></p>
<p>可见, 希尔排序实际上就是不断的进行直接插入排序, 分组是为了先将局部元素有序化. 因为直接插入排序在元素基本有序的状态下, 效率非常高. 而希尔排序呢, 通过先分组后排序的方式, 制造了直接插入排序高效运行的场景. 因此希尔排序效率更高.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 6、希尔排序 **/</span></span><br><span class="line"><span class="comment">//封装直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dirSort</span>(<span class="params">array, grap</span>) </span>&#123;</span><br><span class="line">    grap = <span class="built_in">arguments</span>[<span class="number">1</span>] ? grap : <span class="number">1</span>;  <span class="comment">//如果grap传值了，则为grap传入的值，如果没有，则从1开始</span></span><br><span class="line"><span class="comment">//        debugger;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = grap - <span class="number">1</span>, len = array.length; i &lt; len; i++) &#123; <span class="comment">//直接从第grap-1个开始比较</span></span><br><span class="line">        <span class="keyword">let</span> current = array[i];  <span class="comment">//将这次要比较的值存储起来，作为这一轮循环里面的常量</span></span><br><span class="line">        <span class="keyword">let</span> index = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只比较分组内的最大步长间距的两个数，循环一次就跳出来</span></span><br><span class="line">        <span class="keyword">while</span> (current &lt; array[index - grap] &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            array[index] = array[index - grap];  <span class="comment">//如果当前比较的数小于它的前一位，则将大的数后移一位</span></span><br><span class="line">            index -= grap;    <span class="comment">//于此同时，下标也前移grap，继续下一次比较</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index !== i) &#123;  <span class="comment">//防止自己赋值给自己，</span></span><br><span class="line">            array[index] = current; <span class="comment">//如果不是自己，则一定是之前后移空出来留给current的位置，插入进去</span></span><br><span class="line">            <span class="built_in">console</span>.log(array)</span><br><span class="line"><span class="comment">//                debugger</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> gra = array.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dirSort(array, gra);</span><br><span class="line">        gra = gra &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h3><p>这是一种使用非常广泛的排序，典型的代表就是Chrome的v8引擎为了高效排序, 在排序数据超过了10条时, 便会采用快速排序. 对于10条及以下的数据采用的便是插入排序</p>
<p>快速排序”的思想很简单，整个排序过程只需要三步：<br>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br><img src="/assets/sort09.gif" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 7、快速排序 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//选取基准点，基准点选取的好坏决定了排序速度的好坏，目前没有好的方法，一般居中选取</span></span><br><span class="line">        <span class="keyword">let</span> baseIndex = array.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> left = [], right = [];  <span class="comment">//定义基准点左右两边数组，小的都在左边，大的都在右边</span></span><br><span class="line">        <span class="comment">// 循环判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i !== baseIndex) &#123;       <span class="comment">//这一步很关键，一定不能把自身算进去</span></span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[baseIndex]) &#123;</span><br><span class="line">                    left.push(array[i])</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    right.push(array[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//          最关键的一步：递归调用然后在用数组拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(left).concat(array[baseIndex], <span class="built_in">arguments</span>.callee(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/sort9_1.png" alt=""></p>
<h3 id="8、归并排序"><a href="#8、归并排序" class="headerlink" title="8、归并排序"></a>8、归并排序</h3><p>归并排序建立在归并操作之上, 它采取分而治之的思想, 将数组拆分为两个子数组, 分别排序, 最后才将两个子数组合并; 拆分的两个子数组, 再继续递归拆分为更小的子数组, 进而分别排序, 直到数组长度为1, 直接返回该数组为止.</p>
<p><img src="/assets/sort08.gif" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 8、归并排序 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="comment">//上半部分拆分数组，</span></span><br><span class="line">        <span class="keyword">let</span> baseIndex = array.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> left = array.slice(<span class="number">0</span>, baseIndex),</span><br><span class="line">            right = array.slice(baseIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并数组，</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">                <span class="keyword">let</span> item = left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift();</span><br><span class="line">                res.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.concat(left.length ? left : right);  <span class="comment">//返回排好数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用，一边拆分，一边合并</span></span><br><span class="line">        <span class="keyword">return</span> merge(<span class="built_in">arguments</span>.callee(left), <span class="built_in">arguments</span>.callee(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/sort8_1.png" alt=""></p>
<h3 id="9、堆排序"><a href="#9、堆排序" class="headerlink" title="9、堆排序"></a>9、堆排序</h3><h3 id="10、计数排序"><a href="#10、计数排序" class="headerlink" title="10、计数排序"></a>10、计数排序</h3><p>计数排序利用了一个特性, 对于数组的某个元素, 一旦知道了有多少个其它元素比它小(假设为m个), 那么就可以确定出该元素的正确位置(第m+1位)</p>
<ol>
<li>获取待排序数组A的最大值, 最小值.</li>
<li>将最大值与最小值的差值+1作为长度新建计数数组B，并将相同元素的数量作为值存入计数数组.</li>
<li>对计数数组B累加计数, 存储不同值的初始下标.</li>
<li>从原数组A挨个取值, 赋值给一个新的数组C相应的下标, 最终返回数组C.</li>
</ol>
<p><img src="/assets/sort10.gif" alt=""></p>
<h3 id="11、桶排序"><a href="#11、桶排序" class="headerlink" title="11、桶排序"></a>11、桶排序</h3><p>桶排序即所谓的箱排序, 它是将数组分配到有限数量的桶子里. 每个桶里再各自排序(因此有可能使用别的排序算法或以递归方式继续桶排序). 当每个桶里的元素个数趋于一致时, 桶排序只需花费O(n)的时间. 桶排序通过空间换时间的方式提高了效率, 因此它需要额外的存储空间(即桶的空间).</p>
<h3 id="12、基数排序"><a href="#12、基数排序" class="headerlink" title="12、基数排序"></a>12、基数排序</h3><p>基数排序源于老式穿孔机, 排序器每次只能看到一个列. 它是基于元素值的每个位上的字符来排序的. 对于数字而言就是分别基于个位, 十位, 百位 或千位等等数字来排序. (不明白不要紧, 我也不懂, 请接着往下读)<img src="/assets/sort12.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/12/JS-数组排序算法/" data-id="cjfmorioc001dr0jit5i1v9la" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/12/JS-日期格式化/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          日期格式化.md
        
      </div>
    </a>
  
  
    <a href="/2018/03/08/JS-数组、字符串中最大、重复元素查找/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">找最大值、重复元素.md</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a><span class="tag-list-count">32</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/05/JS-继承/">JavaScript继承实现的几种方法.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/Linux-Linux下常用命令/">linux命令.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-AJAX使用详细介绍/">Ajax介绍.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/Linux-README/">readme.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-闭包/">JavaScript闭包.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Xia Ao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">档案</a>
  
    <a href="/tags" class="mobile-nav-link">分类</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>