{"meta":{"title":"夏夏","subtitle":null,"description":null,"author":"Xia Ao","url":"http://yoursite.com"},"pages":[],"posts":[{"title":":2018-4-5闭包.md","slug":"2018-4-5闭包-md","date":"2018-04-05T11:40:01.000Z","updated":"2018-04-05T11:40:01.591Z","comments":true,"path":"2018/04/05/2018-4-5闭包-md/","link":"","permalink":"http://yoursite.com/2018/04/05/2018-4-5闭包-md/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":":2018-:4-:5-:运算符.md","slug":"2018-4-5-运算符-md","date":"2018-04-05T11:39:21.000Z","updated":"2018-04-05T11:41:06.987Z","comments":true,"path":"2018/04/05/2018-4-5-运算符-md/","link":"","permalink":"http://yoursite.com/2018/04/05/2018-4-5-运算符-md/","excerpt":"","text":"7种基本数据类型 6种原始类型 null 表示缺少的标识，指示变量未指向任何对象。 undefined 是全局对象的一个属性 Boolean Number String Symbol（ES6中新定义） Object 另一种区分方式1、值类型：即5种基本类型（string,number,boolean,null,undefined）； 2、引用类型：即数组、函数、对象共三种。这三种类型的处理与值类型会有很大的差别。 JS中常用的内置对象 date时间对象 string字符串对象 Math数学对象， Number数值对象， Array数组对象， function函数对象, arguments函数参数集合, Boolean布尔对象， Error错误对象, Object基础对象 记住以下结果 null与undefined区别javaScript设计者最初是这样设计的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 后来在使用的过程中这样区分null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。 12345678910111213141516typeof null // object (因为一些以前的原因而不是'null')typeof undefined // \"undefined\"null === undefined // falsenull == undefined // truenull === null // trueundefined === undefined// true!null //true!undefined //trueisNaN(1 + null) // false null转化为Number时为0isNaN(1 + undefined) // true undefined转化为Number时为NaN1+null //11+undefined //NaN//但是要记住，null能转化为Number进行计算null == 0 //falseundefined == 0 // false null与Object 12null==Object //falsenull===Object //false 12345[]==![] //true[]==false //true![] //false!&#123;&#125; //false 严格相等===两个被比较的值在比较前都不进行隐式转换 非严格相等 ==在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符=== 的比较方式。 关于 Object.is(A,B)区分和严格相等===之间的区别 12345678Object.is(-0 , +0) //false-0 === +0 //trueObject.is(NaN , NaN) //trueNaN === NaN //false[1,2] == '1,2' //true[1,2] === '1,2' //false ToNumber 12Number(&apos;&apos;) // 0Number(&apos;a123&apos;) //NaN input result null +0 undefined NaN Boolean +0 / 1 Number 不转换 String Symbol 报错 Object ToNumber(ToPrimitive( input , Number)) ToPrimitive()关于隐式转换参考这篇文章：js隐式装箱-ToPrimitive 默认用法：ToPrimitive(input [,PreferredType])，（ToPrimitive方法可被修改） 如果是Date求原值，则PreferredType是String，其他均为Number。 PreferredType是String，则先调用toString()，结果不是原始值的话再调用valueOf()，还不是原始值的话则抛出错误； PreferredType是Number，则先调用valueOf()再调用toString()。 + -操作符在加法的过程中，首先把等号左右两边进行了求原值ToPrimitive()操作，然后如果两个原值只要有一个是String类型，就把两个原值都进行转化字符串ToString()操作，进行字符串拼接；否则把两个原值都进行转化数字ToNumber()操作，进行数字相加。 12345678910111213141516171819202122232425262728+[] //0+[0] //0+&#123;&#125; //NaN[] + [] // \"\"// PreferredType是Number，则先调用valueOf()再调用toString()。 []==&gt;[]==&gt;\"\"&#123;&#125; + &#123;&#125; //\"[object Object][object Object]\"//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;\"[object Object]\"[] + &#123;&#125; // \"[object Object]\"//[]==&gt;[] ==&gt;\"\"//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;\"[object Object]\"// 然后字符串拼接&#123;&#125; + [] // 0// 原因在于&#123;&#125;在前，被当成&#123;&#125;;直接执行了，变成了 +[],[]的原值是\"\",+[]需要进行toNumber转换变成了0 ，最后结果为0++[[ ]][+[ ]]+[+[ ]]//这个就有意思了，一开始对[][]理解错了，以为是二维数组，二维数组是name[i][j],这个才是对二维数组的调用，[][]是对前面那个一维数组的调用，数组名就是第一个[].拆分：&gt;&gt; ++[[]][+[]] + [+[]] 很明显 我们知道+[]的结果是0&gt;&gt; ++[[]][0] + [0] 这里我们就看到是对数组[[]]的第0位进行操作，即[]&gt;&gt; ++[] + [0]&gt;&gt; ([]+1) + [0]&gt;&gt; (''+1) + [0]&gt;&gt; '1' + [0]&gt;&gt;'10' 下列表达式输出什么 123456console.log(1 + \"2\" + \"2\");console.log(1 + +\"2\" + \"2\");console.log(1 + -\"1\" + \"2\");console.log(+\"1\" + \"1\" + \"2\");console.log( \"A\" - \"B\" + \"2\");console.log( \"A\" - \"B\" + 2); 123456'122''32''02''112''NaN2'NaN 运算过程注意一下几点： 多个数字和数字字符串混合运算时，跟操作数的位置有关 12console.log(2 + 1 + '3'); // '33'console.log('3' + 2 + 1); //'321' 数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字，同样，可以在数字前添加‘’，将数字转为字符串 1234console.log(typeof '3'); // stringconsole.log(typeof +'3'); //numberconsole.log(typeof 3); // numberconsole.log(typeof (''+3)); //string 对于运算结果不能转换成数字的，将返回 NaN 12consol.log('a' * 'sd'); //NaNconsole.log('A' - 'B'); // NaN 给基本类型数据添加属性，不报错，但取值时是undefined123456var a = 10;a.pro = 10;console.log(a.pro + a); //undefinedvar s = 'hello';s.pro = 'world';console.log(s.pro + s); //'undefinedhello' a.pro和s.pro都为undefined。给基本类型数据加属性不报错，但是引用的话返回undefined，10+undefined返回NaN，而undefined和string相加时转变成了字符串。 A &amp;&amp; B 与 A || BA &amp;&amp; B与运算，会做boolean转换，当A为false时返回A的结果，当A为true时返回B的结果，A||B 或运算，当A为true时返回A的结果，当A为false时返回B的结果。 instanceof运算符详解这里有一篇博文，详细介绍的instanceof运算符的历史由来以及定义 先说typeof运算符，判断数据类型，对于基本类型，返回基本类型，对于引用类型的，不管哪一种引用类型，都返回’object’ instanceof 运算符通常用来判断一个实例是否属于某种类型，使用方法为foo instanceof Foo返回一个Boolean值因为这个原因，更多的时候在继承关系中，用来判断实例是否属于一个父类型。 instanceof如何实现这样的功能，语言规范里面有详细的介绍，这里截取js表达的方式 123456789101112&gt;function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125; &#125;&gt; 由规范得到，instanceof将前面表达式的__proto__与后面的表达式的prototype进行严格相等===比较，如果相等返回true，如果不相等，则继续循环获取前面表达式的__proto__，直到 Object.__proto__===null为止返回false。 123456789console.log(Object instanceof Object);//true console.log(Function instanceof Function);//true console.log(Number instanceof Number);//false console.log(String instanceof String);//false console.log(Function instanceof Object);//true console.log(Foo instanceof Function);//true console.log(Foo instanceof Foo);//false","categories":[],"tags":[],"keywords":[]},{"title":"array操作方法.md","slug":"array操作方法-md","date":"2018-04-05T11:28:21.000Z","updated":"2018-04-05T11:32:03.371Z","comments":true,"path":"2018/04/05/array操作方法-md/","link":"","permalink":"http://yoursite.com/2018/04/05/array操作方法-md/","excerpt":"","text":"JavaScript继承的实现继承的实现基于原型链,参考js从原型到原型链 下面聊一聊JS继承实现的几种方法： 先定义一个父类Animal，有一个属性，一个实例方法，一个原型方法123456789101112131415/** 初始化一个父类 **/// 定义一个动物类function Animal(name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function () &#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function (food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 1、原型链继承将父类的实例作为子类的原型son.prototype = new father()12345678910111213/** 1、原型链继承 - 将父类的实例作为子类的原型**/function Cat() &#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new Cat();console.log(cat.name); //catcat.sleep(); //cat正在睡觉！cat.eat('fish'); //cat正在吃：fishconsole.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 2、构造函数继承使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）这里用到了Animal.call(this);，就是讲Animal的属性和方法等创建到了cat对象里面，但是Animal的原型方法不能创建到cat对象。 12345678910111213/** 2、构造函数 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // trueconsole.log(cat.eat('fish')); //报错Uncaught TypeError: cat.eat is not a function 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3、实例继承为父类实例添加新特性，作为子类实例返回 1234567891011121314/** 3、实例继承 **/function Cat(name) &#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat('jack');console.log(cat.name); //jackconsole.log(cat.sleep()); //jack正在睡觉！console.log(cat.eat('fish')); //jack正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 4、拷贝继承这是没有什么特点，就是遍历对象，拷贝继承 12345678910111213141516/** 4、拷贝继承 **/function Cat(name) &#123; var animal = new Animal(); for (var p in animal) &#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat('fish')); //Tom正在吃：fishconsole.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5、组合继承结合原型继承和构造函数继承两种方法，通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。 12345678910111213141516/** 5、组合继承 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat; //要修改函数的执行// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat('fish')); //Tom正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6、寄生组合继承通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点12345678910111213141516171819202122/** 6、寄生组合继承 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;(function () &#123; // 创建一个没有实例方法的类 var Super = function () &#123; &#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat()); //Tom正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 完美方法，但是复杂。 在实际应用中。 参考：JS实现继承的几种方式","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-13T16:29:27.252Z","updated":"2018-03-13T16:31:22.392Z","comments":true,"path":"2018/03/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}