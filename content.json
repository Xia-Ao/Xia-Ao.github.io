{"meta":{"title":"夏夏盟主","subtitle":null,"description":null,"author":"Xia Ao","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-04-05T06:35:18.733Z","updated":"2018-04-05T06:35:18.733Z","comments":true,"path":"assets/REMADE.html","permalink":"http://yoursite.com/assets/REMADE.html","excerpt":"","text":""}],"posts":[{"title":"本机更换SSH公钥密钥后如何再通过ssh方式登录服务器.md","slug":"Linux-SSH连接","date":"2018-04-21T18:05:40.000Z","updated":"2018-04-22T02:32:13.074Z","comments":true,"path":"2018/04/22/Linux-SSH连接/","link":"","permalink":"http://yoursite.com/2018/04/22/Linux-SSH连接/","excerpt":"","text":"通常我们在够买vps的时候，或者第一次配置ssh登录的时候，就会将本机的ssh公钥添加的云平台上去，在初始化vps时，云平台会将添加的ssh公钥添加到用户的/user/.ssh/authorized_keys文件中，例如，如果用户是root用户，则公钥位于/root/.ssh/authorized_keys文件。这样，在vps中具有你本机的公钥，在本机使用下面命令就可以连接，大多数平台都是这样。1ssh root@yourVpsIp 但是又一次我作死了，由于谷歌云我使用ssh连接的时候用户弄错了，一直提示我没用次用户的公钥，不知道什么原因，我头脑一热，重新生成了本机的ssh公钥密钥，然后将谷歌云的上的公钥删掉，换成新生成的公钥。之久就怎么也连不上去了，以前使用浏览器的ssh连接方式也连不上了。开始了无尽的作死之路。 主要的因为，在vps初始化的时候，将平台的公钥添加的用户的ssh目录下，但是后面如果修改了平台的ssh公钥，vps用户中的authorized_keys并不会同步，只有将authorized_keys内容同步为新的公钥即可。但是谷歌云的话，由于将之前的公钥删除，怎么都连接不上去，都没法操作vps，所以只有重置vps，我选择了关停这台vps，重新购买了一台，将之前的静态IP重新绑定到新的vps。然后顺利连接。 上面的方法比较极端，下面就来介绍一个不用清空vps的方法。 由于我重新生成了本机的ssh公钥密钥，所有我的github，coding平台重新添加ssh公钥就可以了，这个和vps不一样，是可以同步的。但是我的digitalOcean服务器就没有那么好的运气了。也遇到了之前谷歌云一样的问题。登录时提示在vps中没有该用户的公钥。 解决方案： 1、在digitalOcean平台重新添加新的公钥2、使用账号密码通过网页版控制台登录。cat /root/.ssh/authorized_keys，发现是之前的ssh公钥，并没有的更新，准备手动修改。但是这个网页版做的很不好，没法复制粘贴命令，所以也没法将公钥贴进去，不可能一个一个手敲吧，然后也不能使用上传。这就比较麻烦了将次，后面想到使用文件下载，将文件传输到vps，替换原文件。一开始准备使用百度网盘链接，但是链接地址也是比较长，手敲也不现实，后面想到使用git下载。3、使用git仓库下载。在本地创建一个authorized_keys文件，将公钥复制粘贴进去，然后创建一个git仓库，将authorized_keys文件上传到仓库。然后再vps中安装git apt-get install git,使用git克隆这个仓库到指定的文件路径1git clone http://github.com/Xia-Ao/仓库名 这样vps就得到了authorized_keys，将root用户下的文件替换掉就可以了。然后使用ssh root@yourVpsIP登录。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"JavaScript继承实现的几种方法.md","slug":"JS-继承","date":"2018-04-05T14:21:40.000Z","updated":"2018-04-05T14:49:33.392Z","comments":true,"path":"2018/04/05/JS-继承/","link":"","permalink":"http://yoursite.com/2018/04/05/JS-继承/","excerpt":"","text":"JavaScript继承的实现继承的实现基于原型链,参考js从原型到原型链 下面聊一聊JS继承实现的几种方法： 先定义一个父类Animal，有一个属性，一个实例方法，一个原型方法123456789101112131415/** 初始化一个父类 **/// 定义一个动物类function Animal(name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function () &#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function (food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 1、原型链继承将父类的实例作为子类的原型son.prototype = new father()12345678910111213/** 1、原型链继承 - 将父类的实例作为子类的原型**/function Cat() &#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new Cat();console.log(cat.name); //catcat.sleep(); //cat正在睡觉！cat.eat('fish'); //cat正在吃：fishconsole.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 2、构造函数继承使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）这里用到了Animal.call(this);，就是讲Animal的属性和方法等创建到了cat对象里面，但是Animal的原型方法不能创建到cat对象。 12345678910111213/** 2、构造函数 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // trueconsole.log(cat.eat('fish')); //报错Uncaught TypeError: cat.eat is not a function 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3、实例继承为父类实例添加新特性，作为子类实例返回 1234567891011121314/** 3、实例继承 **/function Cat(name) &#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat('jack');console.log(cat.name); //jackconsole.log(cat.sleep()); //jack正在睡觉！console.log(cat.eat('fish')); //jack正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 4、拷贝继承这是没有什么特点，就是遍历对象，拷贝继承 12345678910111213141516/** 4、拷贝继承 **/function Cat(name) &#123; var animal = new Animal(); for (var p in animal) &#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat('fish')); //Tom正在吃：fishconsole.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5、组合继承结合原型继承和构造函数继承两种方法，通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。 12345678910111213141516/** 5、组合继承 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat; //要修改函数的执行// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat('fish')); //Tom正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6、寄生组合继承通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点12345678910111213141516171819202122/** 6、寄生组合继承 **/function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;(function () &#123; // 创建一个没有实例方法的类 var Super = function () &#123; &#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name); //Tomconsole.log(cat.sleep()); //Tom正在睡觉！console.log(cat.eat()); //Tom正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 完美方法，但是复杂。 7、使用ES6中的extends实现继承extends继承肯定是最好的继承方法，优先推荐使用. 12345678910111213141516171819202122232425262728/** 7、extends继承 **/class Animal &#123; constructor(name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function () &#123; console.log(this.name + '正在睡觉！'); &#125; &#125; eat(food) &#123; console.log(this.name + '正在吃：' + food); &#125;&#125;class Cat extends Animal &#123; constructor() &#123; super('jack'); &#125;&#125;var cat = new Cat();console.log(cat.name); //jackcat.sleep(); //jack正在睡觉！cat.eat('fish'); //jack正在吃：fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 在实际应用中。 参考：JS实现继承的几种方式","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"readme.md","slug":"Linux-README","date":"2018-04-05T12:05:40.000Z","updated":"2018-04-05T12:18:32.199Z","comments":true,"path":"2018/04/05/Linux-README/","link":"","permalink":"http://yoursite.com/2018/04/05/Linux-README/","excerpt":"","text":"","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Ajax介绍.md","slug":"JS-AJAX使用详细介绍","date":"2018-04-05T12:05:40.000Z","updated":"2018-04-05T12:46:47.066Z","comments":true,"path":"2018/04/05/JS-AJAX使用详细介绍/","link":"","permalink":"http://yoursite.com/2018/04/05/JS-AJAX使用详细介绍/","excerpt":"","text":"关于Ajax请求这部分内容，有一篇博文江讲解的十分详细 原文地址：路易斯-Ajax知识体系大梳理个人总结几个知识点 1、ajax请求，浏览器线程处理过程。 这个过程跨越了解一下浏览器重绘和回流 2、XMLHttpRequest属性来源于继承1xhr &lt;&lt; XMLHttpRequest.prototype &lt;&lt; XMLHttpRequestEventTarget.prototype &lt;&lt; EventTarget.prototype &lt;&lt; Object.prototype ajax实例1234567891011121314151617181920212223function loadXMLDoc()&#123; var xml; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xml=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xml=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; xml.onreadystatechange=function() &#123; if ((xml.readyState==4 &amp;&amp; xml.status==200) || xml.status==304) &#123; document.getElementById(\"myDiv\").innerHTML=xml.responseText; &#125; &#125; xml.open(\"GET\",\"/try/ajax/ajax_info.txt\",true); xml.send();&#125; 3、XMLHttpRequest属性内容一个xhr实例对象拥有10个普通属性+9个方法.readyState onreadystatechangestatusstatusTextonloadstartonprogressonloadonloadendtimeoutontimeout 4、jquery封装ajax方法$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要. 5、Axios Axios支持node, jquery并不支持. Axios基于promise语法, jq3.0才开始全面支持. Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢. vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 6、 CORS跨域资源共享CORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)CORS请求分为两种, ① 简单请求; ② 非简单请求. 满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客) 1) 请求是以下三种之一: HEAD GET POST 2) http头域不超出以下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type字段限三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 Origin 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 Access-Control-_ 等字段.对于非简单请求, 比如Method为POST且Content-Type值为 application/json 的请求或者Method为 PUT 或 DELETE 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 Access-Control-_ 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发). 4、跨越解决方案跨域解决方案可以参考另一篇有关同源策略到前端跨域。ajax的跨域主要有CROS、 使用代理、JSONP、webSocket这几种方案，具体的都在上面同源策略到前端跨域。 5、ajax文件上传6、ajax请求二进制文件7、ajax缓存处理js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存. 123xhr.setRequestHeader(\"If-Modified-Since\",\"0\");xhr.setRequestHeader(\"Cache-Control\",\"no-cache\");//或者 URL 参数后加上 \"?timestamp=\" + new Date().getTime() jquery的http缓存是否开启可通过在settings中指定cache. 1234567$.ajax(&#123; url : 'url', dataType : \"xml\", cache: true,//true表示缓存开启, false表示缓存不开启 success : function(xml, status)&#123; &#125;&#125;); 1$.ajaxSetup(&#123;cache:false&#125;); //全局关闭ajax缓存. 除此之外, 调试过程中出现的浏览器缓存尤为可恶. 建议开启隐私浏览器或者勾选☑️控制台的 Disable cache 选项. 8、 ajax错误处理前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外) 实际上, $.ajax 方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 $.ajax 的error回调便会触发. 9、ajax调试技巧使用node-server配置服务器调试。如何搭建node-server参考他的另一篇node-server","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"linux命令.md","slug":"Linux-Linux下常用命令","date":"2018-04-05T12:05:40.000Z","updated":"2018-04-05T12:18:18.160Z","comments":true,"path":"2018/04/05/Linux-Linux下常用命令/","link":"","permalink":"http://yoursite.com/2018/04/05/Linux-Linux下常用命令/","excerpt":"","text":"###复制copy ,cp，该命令的功能是将给出的文件或目录拷贝到另外一个文件或目录中。语法： cp [选项] 源文件或目录 目标文件或目录 ####1、普通复制例如;在/TEST目录下新建test1和test2两个子文件夹。 假设复制源文件test1下的test01文件，目标目录为test2cp /TEST/test1/test01 /TEST/test2 ####2、对一个文件夹中的全部文件复制到另外一个文件夹中去cp -r /TEST/test1/. /TEST/test2把test1中的文件夹及文件复制到test2中","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JavaScript闭包.md","slug":"JS-闭包","date":"2018-04-05T04:05:40.000Z","updated":"2018-04-05T14:43:57.500Z","comments":true,"path":"2018/04/05/JS-闭包/","link":"","permalink":"http://yoursite.com/2018/04/05/JS-闭包/","excerpt":"","text":"闭包阮一峰学习闭包 闭包的概念高程上关于闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数 简单理解就是：定义在一个函数内部的函数 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 创建闭包的方式：在一个函数内部创建另一个函数 123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 其中f2( )就是一个闭包能够访问它上一级函数f1()中的变量n。 闭包关于作用域链的图示： 闭包的用途1、读取其他函数内部的变量 2、让这些变量的始终保持在内存中，这是一个双刃剑，可以方便的访问内部的变量，即使函数执行完成，其内部变量还保存在内存中可以访问，但是也会带来一系列的问题，外部函数的作用域链和变量对象不能销毁，占用内存。 来看一个典型的例子 12345678910var result = new Array(); function createFunctions()&#123; for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; console.log(i); &#125;; &#125; &#125;result[6](); //10 从表面上看，似乎每一个函数都返回10 ，但实际上，每个函数都返回10， 因为每个函数的作用域链中都保存着父级函数的活动对象，他们的引用的都是同一个变量i，当父级函数return result 后，变量i的值变成10 ，每个函数引用保存变量i的同一个变量对象，因为此时i=10，所以引用变量指向的值都变成10。 解决这个问题最方便的一个方法是将闭包函数立即执行，每次引用都变成实际i对应的值。每次循环立即执行后销毁引用变量。 12345678910111213var result = new Array(); function createFunctions()&#123; for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; var c = i; return function () &#123; console.log(c); &#125;; &#125;(); &#125; &#125;result[6](); //6 闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 闭包中的this匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window 闭包的this对象一般也是指向window。具体使用用要看具体的情况，有没有实例化对象，有没有使用apply() call() 等来改变this对象。 面试中问到关于函数闭包的问题f(a)(b); 要求返回a+b的结果。 面试的时候面试官写出这样的一个表达式，猛一看这个心想坏了，这是什么表达式，我都没见过，一脸懵逼，一开始以为则是一个立即执行函数，仔细一看不对，这是一个函数执行之后再跟一个()表示执行，还好面试官提示一下，后面的括号就是表示执行函数，那前面的f(a)表示执行结果返回的是一个函数。 接下来就是写这个函数：两种思路，一种我自己想的，一种网上的，当然是晚上的比较好 1、使用闭包1234567function f(x) &#123; return function(y)&#123; return x+y &#125;&#125;console.log(f(2)); //返回一个函数console.log(f(2)(3)); //5 这种方法明显的好，使用闭包，函数里面封装一个函数。最为关键的点在于，闭包就是能够读取其他函数内部变量的函数，就相当于把第一次执行时传入的参数x定义为了一个变量，因为在闭包函数中有对x的引用，所以在函数f执行完成之后，内存中x变量的值并没有被清空，在第二次执行的时候可以正常访问到x，并返回x+y。 其实这个问题在阮一峰-关于闭包的学习中有这个表达式，当时自己看的时候只注意到闭包的作用域，没有注意到函数执行表达式。 2、我的方法我的方法就比较笨， 将闭包特有的性质单独拿出来实现。 1234567891011let temp;function f() &#123; if (temp) &#123; return temp * arguments[0] &#125; else &#123; temp = arguments[0] return f; &#125;&#125;console.log(f(2)); //返回一个函数console.log(f(2)(3)); //5","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"数据结构之神奇的树.md","slug":"JS-data-structure","date":"2018-04-05T02:15:40.000Z","updated":"2018-04-05T14:47:10.586Z","comments":true,"path":"2018/04/05/JS-data-structure/","link":"","permalink":"http://yoursite.com/2018/04/05/JS-data-structure/","excerpt":"","text":"树基础的就不说了，可以参考JavaScript数据结构与算法。 树的几个操作几点，root，node.key，node.left， node.right， 树的操作一般都会用到递归调用。 中序遍历 先序遍历 后序遍历","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"DOM遍历.md","slug":"JS-DOM遍历","date":"2018-04-04T17:05:40.000Z","updated":"2018-04-05T14:47:10.607Z","comments":true,"path":"2018/04/05/JS-DOM遍历/","link":"","permalink":"http://yoursite.com/2018/04/05/JS-DOM遍历/","excerpt":"","text":"DOM遍历DOM的遍历分为先序遍历，中序遍历， 后序遍历，是三种不同的顺序的遍历方法 三种方法的区别以及原理请参考： https://www.jianshu.com/p/456af5480cee http://blog.csdn.net/u013468917/article/details/69556547 先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右) 中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右) 后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根) 这里只说一下用来遍历的方法：这篇博文写了五种先序遍历的方法，优先使用DOM中提供的两个专门用来遍历的方法。 这两个方法在《JavaScript高程》中有详细的介绍：可以参考第12章12.3 NodeIterator 123456789101112/** * 使用DOM2的\"Traversal\"模块提供的NodeIterator先序遍历DOM树 * @param node 根节点 */function traversalUsingNodeIterator(node)&#123; var iterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT,null,false); var node = iterator.nextNode(); while(node != null)&#123; console.log(node.tagName); node = iterator.nextNode(); &#125;&#125; TreeWalkerNodeIterator更高级的一个版本，主要使用的nextNode()方法 123456789101112131415/** * 使用DOM2的\"Traversal\"模块提供的TreeWalker先序遍历DOM树 * @param node 根节点 */function traversalUsingTreeWalker(node)&#123; var treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT,null,false); if(node &amp;&amp; node.nodeType === 1)&#123; console.log(node.tagName); &#125; var node = treeWalker.nextNode(); while(node != null)&#123; console.log(node.tagName); node = treeWalker.nextNode(); &#125;&#125; 使用DOM扩展的Element Traversal API，递归遍历DOM树1234567891011121314/** * 使用DOM扩展的Traversal API提供的新的接口先序遍历DOM树 * @param node 根节点 */function traversalUsingTraversalAPI(node)&#123; if(node &amp;&amp; node.nodeType === 1)&#123; console.log(node.tagName); &#125; var i = 0,len = node.childElementCount, child = node.firstElementChild; for(; i &lt; len ; i++)&#123; traversalUsingTraversalAPI(child); child = child.nextElementSibling; &#125;&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JavaScript遍历方法对比以及适用对象.md","slug":"JS-遍历","date":"2018-03-25T14:24:40.000Z","updated":"2018-04-05T14:49:33.441Z","comments":true,"path":"2018/03/25/JS-遍历/","link":"","permalink":"http://yoursite.com/2018/03/25/JS-遍历/","excerpt":"","text":"遍历方法1、for循环语法： 1for\\(let i=0; i&amp;lt;length; i++\\)&#123; 代码&#125; 说明：因为String对象具有length属性，所以可以直接使用String.length进行遍历 适用对象：Array，String，obj没有length，不可以使用for循环 2、for in语法： 1for( let index in对象)&#123; 在此执行代码&#125; 说明：for in 遍历的是key值 使用对象：Array String Object 3、for of语法： 1for(let value of 对象)&#123; 在此执行代码&#125; 说明：for of遍历的value值只要具有遍历器接口Iterator，都可以使用for of 遍历，比如NodeList Set Map Array String 类数组 使用对象：Array String for in 与for of 区别 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。 for...in循环出的是key，for...of循环出的是value 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足 for...of不能循环普通的对象，需要通过和Object.keys()搭配使用 4、forEach语法： 1array.forEach(function(currentValue, index, arr), thisArg) 说明：arr当前元素所属的数组对象。 使用对象：Array 只有array对象有 其他数组遍历、map from filter some every等再加上forEach，这些都是针对于Array进行遍历的， String遍历一种变换的方法，使用split将字符串切割为字符串数组，再对数组进行遍历。 Object遍历除了前面写到的for in遍历Object对象，还有以下几种方法对Object进行遍历 2、Object.keys语法： 1234Object.keys(obj) //个表示给定对象的所有可枚举属性的字符串数组。// 类数组对象var obj = &#123; 0: \"a\", 1: \"b\", 2: \"c\"&#125;;console.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"] 说明：Object.keys返回一个由key值组成的可枚举属性的字符串数组，再对数组进行遍历既可以遍历Object 3、Object.getOwnPropertyNames语法： 1Object.getOwnPropertyNames(obj) //在给定对象上找到的属性对应的字符串数组。 说明：返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串 4、Object.values()语法： Object.values(obj) //一个包含对象自身的所有可枚举属性值的数组。、 //示例 随机键值的类数组对象 var an_obj = { 100: 'a', 2: 'b', 7: 'c' }; console.log(Object.values(an_obj)); // ['b', 'c', 'a'] 说明：Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 5、Object.entries()语法： Object.entries(obj) //给定对象自身可枚举属性的键值对数组。 //示例 const obj = { foo: 'bar', baz: 42 }; console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ] 说明：Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 参考：JavaScript如何遍历Object","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JS数据类型、运算符容易踩的几个坑.md","slug":"JS-运算符","date":"2018-03-25T14:22:40.000Z","updated":"2018-04-05T14:49:33.576Z","comments":true,"path":"2018/03/25/JS-运算符/","link":"","permalink":"http://yoursite.com/2018/03/25/JS-运算符/","excerpt":"","text":"7种基本数据类型 6种原始类型 null 表示缺少的标识，指示变量未指向任何对象。 undefined 是全局对象的一个属性 Boolean Number String Symbol（ES6中新定义） Object 另一种区分方式1、值类型：即5种基本类型（string,number,boolean,null,undefined）； 2、引用类型：即数组、函数、对象共三种。这三种类型的处理与值类型会有很大的差别。 JS中常用的内置对象 date时间对象 string字符串对象 Math数学对象， Number数值对象， Array数组对象， function函数对象, arguments函数参数集合, Boolean布尔对象， Error错误对象, Object基础对象 记住以下结果 null与undefined区别javaScript设计者最初是这样设计的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 后来在使用的过程中这样区分null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。 12345678910111213141516typeof null // object (因为一些以前的原因而不是'null')typeof undefined // \"undefined\"null === undefined // falsenull == undefined // truenull === null // trueundefined === undefined// true!null //true!undefined //trueisNaN(1 + null) // false null转化为Number时为0isNaN(1 + undefined) // true undefined转化为Number时为NaN1+null //11+undefined //NaN//但是要记住，null能转化为Number进行计算null == 0 //falseundefined == 0 // false null与Object 12null==Object //falsenull===Object //false 12345[]==![] //true[]==false //true![] //false!&#123;&#125; //false 严格相等===两个被比较的值在比较前都不进行隐式转换 非严格相等 ==在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符=== 的比较方式。 关于 Object.is(A,B)区分和严格相等===之间的区别 12345678Object.is(-0 , +0) //false-0 === +0 //trueObject.is(NaN , NaN) //trueNaN === NaN //false[1,2] == '1,2' //true[1,2] === '1,2' //false ToNumber 12Number(&apos;&apos;) // 0Number(&apos;a123&apos;) //NaN input result null +0 undefined NaN Boolean +0 / 1 Number 不转换 String Symbol 报错 Object ToNumber(ToPrimitive( input , Number)) ToPrimitive()关于隐式转换参考这篇文章：js隐式装箱-ToPrimitive 默认用法：ToPrimitive(input [,PreferredType])，（ToPrimitive方法可被修改） 如果是Date求原值，则PreferredType是String，其他均为Number。 PreferredType是String，则先调用toString()，结果不是原始值的话再调用valueOf()，还不是原始值的话则抛出错误； PreferredType是Number，则先调用valueOf()再调用toString()。 + -操作符在加法的过程中，首先把等号左右两边进行了求原值ToPrimitive()操作，然后如果两个原值只要有一个是String类型，就把两个原值都进行转化字符串ToString()操作，进行字符串拼接；否则把两个原值都进行转化数字ToNumber()操作，进行数字相加。 12345678910111213141516171819202122232425262728+[] //0+[0] //0+&#123;&#125; //NaN[] + [] // \"\"// PreferredType是Number，则先调用valueOf()再调用toString()。 []==&gt;[]==&gt;\"\"&#123;&#125; + &#123;&#125; //\"[object Object][object Object]\"//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;\"[object Object]\"[] + &#123;&#125; // \"[object Object]\"//[]==&gt;[] ==&gt;\"\"//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;\"[object Object]\"// 然后字符串拼接&#123;&#125; + [] // 0// 原因在于&#123;&#125;在前，被当成&#123;&#125;;直接执行了，变成了 +[],[]的原值是\"\",+[]需要进行toNumber转换变成了0 ，最后结果为0++[[ ]][+[ ]]+[+[ ]]//这个就有意思了，一开始对[][]理解错了，以为是二维数组，二维数组是name[i][j],这个才是对二维数组的调用，[][]是对前面那个一维数组的调用，数组名就是第一个[].拆分：&gt;&gt; ++[[]][+[]] + [+[]] 很明显 我们知道+[]的结果是0&gt;&gt; ++[[]][0] + [0] 这里我们就看到是对数组[[]]的第0位进行操作，即[]&gt;&gt; ++[] + [0]&gt;&gt; ([]+1) + [0]&gt;&gt; (''+1) + [0]&gt;&gt; '1' + [0]&gt;&gt;'10' 下列表达式输出什么 123456console.log(1 + \"2\" + \"2\");console.log(1 + +\"2\" + \"2\");console.log(1 + -\"1\" + \"2\");console.log(+\"1\" + \"1\" + \"2\");console.log( \"A\" - \"B\" + \"2\");console.log( \"A\" - \"B\" + 2); 123456'122''32''02''112''NaN2'NaN 运算过程注意一下几点： 多个数字和数字字符串混合运算时，跟操作数的位置有关 12console.log(2 + 1 + '3'); // '33'console.log('3' + 2 + 1); //'321' 数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字，同样，可以在数字前添加‘’，将数字转为字符串 1234console.log(typeof '3'); // stringconsole.log(typeof +'3'); //numberconsole.log(typeof 3); // numberconsole.log(typeof (''+3)); //string 对于运算结果不能转换成数字的，将返回 NaN 12consol.log('a' * 'sd'); //NaNconsole.log('A' - 'B'); // NaN 给基本类型数据添加属性，不报错，但取值时是undefined123456var a = 10;a.pro = 10;console.log(a.pro + a); //undefinedvar s = 'hello';s.pro = 'world';console.log(s.pro + s); //'undefinedhello' a.pro和s.pro都为undefined。给基本类型数据加属性不报错，但是引用的话返回undefined，10+undefined返回NaN，而undefined和string相加时转变成了字符串。 A &amp;&amp; B 与 A || BA &amp;&amp; B与运算，会做boolean转换，当A为false时返回A的结果，当A为true时返回B的结果，A||B 或运算，当A为true时返回A的结果，当A为false时返回B的结果。 instanceof运算符详解这里有一篇博文，详细介绍的instanceof运算符的历史由来以及定义 先说typeof运算符，判断数据类型，对于基本类型，返回基本类型，对于引用类型的，不管哪一种引用类型，都返回’object’ instanceof 运算符通常用来判断一个实例是否属于某种类型，使用方法为foo instanceof Foo返回一个Boolean值因为这个原因，更多的时候在继承关系中，用来判断实例是否属于一个父类型。 instanceof如何实现这样的功能，语言规范里面有详细的介绍，这里截取js表达的方式 123456789101112&gt;function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125; &#125;&gt; 由规范得到，instanceof将前面表达式的__proto__与后面的表达式的prototype进行严格相等===比较，如果相等返回true，如果不相等，则继续循环获取前面表达式的__proto__，直到 Object.__proto__===null为止返回false。 123456789console.log(Object instanceof Object);//true console.log(Function instanceof Function);//true console.log(Number instanceof Number);//false console.log(String instanceof String);//false console.log(Function instanceof Object);//true console.log(Foo instanceof Function);//true console.log(Foo instanceof Foo);//false","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"前端性能优化.md","slug":"JS-前端优化","date":"2018-03-23T12:13:40.000Z","updated":"2018-04-05T14:49:33.532Z","comments":true,"path":"2018/03/23/JS-前端优化/","link":"","permalink":"http://yoursite.com/2018/03/23/JS-前端优化/","excerpt":"","text":"前端优化主要方法记住这篇博文-前端性能优化 优化方法脑图： 大图地址：http://naotu.baidu.com/file/535e0e918b3946c04cf87a1ebf32f29d 以下为后续看到优化方法的补充：","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"剑指Offer-JavaScript版-part1.md","slug":"JS-剑指offer-1","date":"2018-03-21T12:15:40.000Z","updated":"2018-04-05T14:49:33.553Z","comments":true,"path":"2018/03/21/JS-剑指offer-1/","link":"","permalink":"http://yoursite.com/2018/03/21/JS-剑指offer-1/","excerpt":"","text":"指offer实战-JavaScript版前言：以前刚学JS的时候，一直觉得前端不怎么需要算法，就是单纯的实现业务功能，现在想想那时候的想法多少天真，可以说用幼稚来形容了。作为一个合格的程序猿，怎么可能不搞算法，前端的算法不会太复杂，一般都是一些比较简单的算法，对照剑指offer，将里面的算法重新实战一遍，代码位置在另一个仓库Offer 1、二维数组中的查找题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：二维数组是有规律的，按照横纵展开，向右向下递增。选取数组右上角的数字，如果该数字等于要查找的数组，则结束。如果大于要查找的数字，则该列都大于要查找的数字，剔除该列，向左移动一列继续查找；如果小于要查找的数字，则该行都小于要查找的数字，剔除该行，向下移动一行继续查找；直到查找到该数字或者查找到左下角还没有匹配，则返回没有匹配。 代码：github 12345678910111213function find(array, target) &#123; let row = array.length - 1; for (let i = row, j = 0; i &gt;= 0 &amp;&amp; j &lt; array[i].length;) &#123; if (target === array[i][j]) &#123; return true &#125; else if (target &gt; array[i][j]) &#123; //目标大于，则下移一行 j++; //向下移动一行 &#125; else &#123; i--; //向左一动一行 &#125; &#125; return false&#125; 2、替换空格题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：当然是直接用正则匹配然后使用replace替换就好了。 代码： 1234function replaceSpace(str) &#123; let reg = new RegExp(/\\s/g); return str.replace(reg, '--')&#125; 3、从尾到头打印链表题目：输入一个链表，从尾到头打印链表每个节点的值。 不懂链表的可以参考《学习JavaScript的数据结构与算法》 思路：先将链表每个结点的值存入数组中，然后通过数组的reverse方法，即可从尾到头打印 代码：Github 12345678function printLinkedList(head) &#123; let arr = []; while (head !== null) &#123; arr.push(head); head = head.next(); &#125; return arr.reverse();&#125; 4、重建二叉树题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路： 代码：Github 5、用两个栈来实现一个队列题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型 思路：栈的操作是后入先出（LIFO），队列的操作是先入先出（FIFO） 代码：Github 1234567891011121314151617let arr1 = [], arr2 = [], result = [];function push(head) &#123; arr2.push(head); return arr&#125;function shift() &#123; if (arr1.length) &#123; arr1.shift() &#125; else if (arr2.length) &#123; arr2.shift() &#125; else &#123; return null &#125; return arr&#125; 6、旋转数组的最小数字题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路：其实剑指Offer中想要表达的是一种寻找数组最小值的二分查找方法，旋转之后原数组分为两个部分，[3,4,5,1,2],前面的部分最小的数肯定大于或等于后面部分最大的数，通过这一点可以节省遍历，典型的二分法。 代码：Github 12345678function rotate(arr) &#123; return arr.sort(function (a, b) &#123; if (a &lt; b) return -1; else return 1 &#125;)[0];// return Math.min.apply(arr, arr);&#125; 7、斐波那契数列题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 思路：传统思路是使用递归，这种方法简单直接，但是会有一个问题，存在严重的效率问题，很多的重复计算，因此，剑指Offer提出一种优化方法，使用内存记录之前的计算结果，从0 ，1 ，2 开始一直到n，计算过的值被记录下来，就不用再计算了。大大的节省了时间。 代码：Github 12345678910111213141516function fibonacci(n) &#123; if (n === 0 || n === 1) return n; else &#123; var one = 0; var two = 1; var result = 0; for (var i = 2; i &lt;= n; i++) &#123; result = one + two; one = two; two = result &#125; return result; &#125; &#125; 8、跳台阶题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：其实就是斐波那契函数的应用，如果n=1则只有一种，如果n=2则有两种,如果n=3，则有前两种之和，记一个函数f(n),则跳法为f(n-1)+f(n-2) 代码：Github 12345678910111213141516function fibonacci(n) &#123; if (n === 1 || n === 2) return n; else &#123; var one = 0; var two = 1; var result = 0; for (var i = 3; i &lt;= n; i++) &#123; result = one + two; one = two; two = result &#125; return result; &#125; &#125; 9、变态跳台阶题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：其实就是斐波那契函数的应用，如果n=1则只有一种，如果n=2则有两种,如果n=3，则有前两种之和在加上自己跳n阶的一种，记一个函数f(n),则跳法为f(n-1)+f(n-2)+…+f(1)+1 代码：Github12345678910111213141516function fibonacci(n) &#123; var arr = [1, 2]; if (n === 1 || n === 2) return arr[n - 1]; else &#123; var result = 0; for (var i = 3; i &lt;= n; i++) &#123; result = 1 + arr.reduce(function (total, currentValue) &#123; return total + currentValue; &#125;); arr.push(result); &#125; return result; &#125;&#125; 10、矩形覆盖题目：我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路：其实就是斐波那契函数的应用，注意题目中是无重叠，如果n=1则只有一种，n=2时则有2种， n=3时，左上角可以横着放也可以竖着放，竖着放的话，右边剩下两列，刚好是f(2)的情况，当横着放的时候，左下角必须横放一个，右边就剩下一列，f(1)，则有f(2)+f(1)种, 因此推导f(n)= f(n-1)+f(n-2) 代码：Github123456789101112131415function rectCover(number) &#123; // write code here var n = number; var arr = [1, 2]; var result = 0; if (n === 1 || n === 2) return arr[n - 1]; else &#123; for (var i = 3; i &lt;= n; i++) &#123; result = arr[arr.length - 1] + arr[arr.length - 2]; arr.push(result); &#125; return result &#125;&#125; 11、二进制中1的个数题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路： 代码：Github ### 题目： 思路： 代码：Github ### 题目： 思路： 代码：Github","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"前端算法题.md","slug":"JS-前端算法题汇总","date":"2018-03-21T12:14:40.000Z","updated":"2018-04-05T14:49:33.510Z","comments":true,"path":"2018/03/21/JS-前端算法题汇总/","link":"","permalink":"http://yoursite.com/2018/03/21/JS-前端算法题汇总/","excerpt":"","text":"前段算法题汇总前言：尝试自己根据思路去使用js实现的算法，发现对于算法有这么几个问题： 算法是严谨的，一般都是设计到循环，所以要思考到循环中的特殊情况以及循环条件。 不能钻牛角尖，无从下笔时，在纸上写思路，根据思路一步一步实现，在实现的过程中，如果遇到问题，不要慌忙推翻之前的思路，细想之后再改善，大的思路如果不是有很大的问题，先不要推翻，不然很容易陷入到取舍两难的境地。 注意算法的调试方法，尤其是输出，断点的灵活应用。 1、数组去重数组去重的几种方法请参照数组操作方法 2、js脚本整理文件整理前： 1234111.232.213 ascqwdwd111.232.213 qwdqwdqw122.31.34.1 wdojqwodjqwp 232.34.13.3 adhwdhwqhd 整理后： 123'111.232.213': [ 'ascqwdwd', 'qwdqwdqw' ],'122.31.34.1': [ 'wdojqwodjqwp' ],'232.34.13.3': [ 'adhwdhwqhd' ] 3、求1000以内所有的质数对于求质数，和判断一个数是不是质数，原理是一样，区别在于求质数是对一群数进行判断，复杂度提高，如果只是判断一个数是不是质数，不要考虑复杂度，直接从2到这个数的平方根开始循环看能不能整除。对于求多少以内的质数，也可以这样，但是这样的时间复杂度就提高了，网上有说几种不同的境界，这里就不介绍，我才用的筛选法，很明显，对于明显不是质数的数，没有做运算，节省的时间。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** 求num中所有质数 * 对比各种求质数的算法，试除法、筛选法两种时间复杂度较低， * 本方法是自己优化的筛选法，因为2,3是比较小的两个质数，大部分数都是他们的倍数，明显不是质数， * 所以使用2,3为基数，先筛选走这些非质数，然后在从5 7等向上筛选，这种方法明显循环次数要少。时间复杂度我也不知道该怎么计算。 * **/function prime(num) &#123; //定义基数数组baseArr，用来存放较小的质数，res存放筛选结果，base存放[2,3] let baseArr = [], res = [], base = []; num = ~~num; //取整 //对2,3 特殊对待 if (num &lt; 4) &#123; if (num === 1) alert('请输入大于1的整数') if (num === 2) base.push(2); else base.push(2, 3) &#125; //筛选剩下的 else &#123; baseArr.push(2, 3); base.push(2, 3); for (let i = 2; i &lt;= num; i++) &#123; //将2,3的倍数剔除，其余的放入res进行下一轮筛选 if (i % 2 !== 0 &amp;&amp; i % 3 !== 0) &#123; res.push(i); &#125; &#125; for (let j = 0; j &lt;= baseArr.length - 1; j++) &#123; //以大于3最小的质数开始筛选， for (let i = 1; i &lt; res.length; i++) &#123; if (res[i] % res[j] === 0 &amp;&amp; i !== j) &#123; //除自身外，其他的是质数的倍数的数被剔除 res.splice(i, 1); &#125; &#125; if (res[j] &lt; Math.sqrt(num)) &#123; //确保基数质数肯定小于sqrt(num) baseArr.push(res[j]); //添加一个新的基数质数。 &#125; &#125; &#125; return base.concat(res) //将特殊的[2,3]加入返回。&#125;console.log(prime(100));// [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]// baseArr = [2,3,5,7] 4、不借助临时变量，进行两个整数的交换123456function exchange(a,b)&#123; b=a-b; a=a-b; b=a+b; return [a,b]&#125; 5、找出数组最大的差值1234function maxDiff(array) &#123; return Math.max.apply(array,array) - Math.min.apply(array,array);&#125;console.log(maxDiff(arr)); 6、","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JS中作用域与变量提升.md","slug":"JS-作用域与变量提升","date":"2018-03-21T12:12:40.000Z","updated":"2018-04-05T14:49:33.487Z","comments":true,"path":"2018/03/21/JS-作用域与变量提升/","link":"","permalink":"http://yoursite.com/2018/03/21/JS-作用域与变量提升/","excerpt":"","text":"ES5中for循环定义的全局变量下面表达式输出的结果为： 123456789101112for(var i=1;i&lt;4;i++)&#123; setTimeout(function () &#123; console.log(i) &#125;,0)&#125;console.log(i)//4 这是for循环执行完成之后，i++此时的i已经变成4，所以for循环之后的所有关于i的值都是4//4//4//4 因为在表达式中定义的var i是全局作用域变量，任何一个地方都可以访问到，并且一定注意，在for循环内，如果都是同步执行的话，则i的值为3，但是如果是类似异步的，for执行完毕之后为i为4，所以所有i的值都为4. 立即执行函数先看一段代码： 12345function ()&#123; ... &#125;()；//或者function fName()&#123; ... &#125;(); 执行结果为: SyntaxError: Unexpected token (，为什么会有这个错误呢？ 要理解两个概念 函数声明 123function name([param[, param[, ... param]]]) &#123; statements&#125; 函数表达式 1//一个匿名函数的函数表达式，被赋值给变量f2: 1234567var f2 = function() &#123; console.log(\"f2\"); &#125;//通过()来调用此函数f2(); 所以我们来看之前报错的原因，这是一个函数声明，后面再接一个() ，js引擎看到function关键字之后，认为后面跟的是函数定义语句，不应该以圆括号结尾，解决这个问题就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。改写成这样。 12345(function()&#123; /* code */ &#125;()); // 或者(function()&#123; /* code */ &#125;)(); 带参数(parameter)有时候看到这样的一种形式，括号中传递一个参数。 1(function (p) &#123; return p&#125;)(parameter); 立即 执行的括号中传入了一个参数，执行的过程中此参数就是函数传入的参数。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JS事件.md","slug":"JS-事件机制","date":"2018-03-20T12:11:40.000Z","updated":"2018-04-05T14:49:33.540Z","comments":true,"path":"2018/03/20/JS-事件机制/","link":"","permalink":"http://yoursite.com/2018/03/20/JS-事件机制/","excerpt":"","text":"事件流 事件代理事件绑定后，检测顺序就会从被绑定的DOM下滑到触发的元素，再冒泡会绑定的DOM上。也就是说，如果你监听了一个DOM节点，那也就等于你监听了其所有的后代节点。 代理的意思就是只监听父节点的事件触发，以来代理对其后代节点的监听，而你需要做的只是通过currentTarget属性得到触发元素并作出回应。 使用事件代理意味着你可以节省大量重复的事件监听，以减少浏览器资源消耗。还有一个好处就是让HTML独立起来，比如之后还有要加子元素的需求，也不需要再为其单独加事件监听了。 事件处理程序DOM0级事件处理就是讲一个函数赋值给一个事件处理程序属性 1btn.onclick=function ()&#123;&#125; DOM2级事件处理程序，这里因为历史原因，IE的事件处理操作API名称和常规的不太一样，所以，一般需要考虑到浏览器兼容，高程上给出了一个扩浏览器的EventUtil对象，会检测是是否支持DOM2级事件处理，以及IE下的情况。优先推荐。注意 ：addEventListener()/removeEventListener()最后一个参数为boolean值，true表示在捕获阶段调用事件处理函数，false表示在冒泡阶段处理。 IE下的attachEvent() detachEvent()没有这个布尔值，因为早期IE只支持冒泡，所以IE处理默认冒泡。 1234567891011121314151617181920212223242526/** DOM2级事件处理程序 浏览器兼容 * IE-attachEvent() detachEvent() * 其他-addEventListener() removeEventListener() * EventUtil: 全局对象 * 使用：EventUtil.addHandler(ele,type,handler) * **/let EventUtil = &#123; addHandler: (element, type, handler) =&gt; &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false) &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, handler) &#125; else &#123; element['on' + type] = handler; &#125; &#125;, removeHandler: (element, type, handler) =&gt; &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false) &#125; else if (element.detachEvent()) &#123; element.detachEvent('on' + type, handler) &#125; else &#123; element['on' + type] = null; &#125; &#125;&#125; 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event ，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 event 对象，但支持方式不同。 当然，在事件对象中IE也有不一样的地方。后面再区别，先看DOM2级事件对象。 在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this 、 currentTarget 和 target 包含相同的值。。如果事件处理程序存在于按钮的父节点中（例如 document.body ），那么这些值是不相同的。 IE中的事件对象 事件类型这里面主要记住UI事件，大部分是window对象相关。 内存和性能优化在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM访问次数，会延迟整个页面的交互就绪时间。当然最直接的就是减少页面中事件处理程序。 优化方案一：使用事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。一个典型的应用就是比如有一批列表，给每一个列表都添加一个事件处理程序，则内存占用比较大，然后操作也比较复杂，如果在DOM中尽量高一层级上添加一个事件处理程序，利用事件冒泡，可以让每一个列表都可以获取到事件处理。这种技术对用户最终的结果与之前的方法差不多，但是需要的内存更少。 使用事件委托技术，与传统方法相比较，有如下优势： 优化方案二：移除时间事件处理程序内存中保留着那些过时不用的“空事件处理程序”，也是造成Web应用程序内存和性能问题的主要原因。两种典型的情况会造成“空事件处理程序占用内存”的问题： 从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的 DOM 操作，例如使用 removeChild() 和 replaceChild() 方法，但更多地是发生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。 一般使用手工移除事件处理程序，btn.onclick=null;，然后再设置innerHTML。 卸载页面。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。 一般来说，最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。 说到 这里，就又可以看到事件委托技术的优势，如果事件追踪的越少，越容易移除。 mouse事件mouseover与mouseenter 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。 mouseout与mouseleave 不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。 只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Object对象及其遍历方法.md","slug":"JS-Object对象","date":"2018-03-15T09:05:40.000Z","updated":"2018-04-05T14:49:33.325Z","comments":true,"path":"2018/03/15/JS-Object对象/","link":"","permalink":"http://yoursite.com/2018/03/15/JS-Object对象/","excerpt":"","text":"Object遍历方法1、for in2、Object.keys3、Object.getOwnPropertyNames4、for … of （ES6）5、Object.values （ES7）6、Object.entries （ES7）","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"递归.md","slug":"JS-递归","date":"2018-03-13T14:23:40.000Z","updated":"2018-04-05T14:49:33.401Z","comments":true,"path":"2018/03/13/JS-递归/","link":"","permalink":"http://yoursite.com/2018/03/13/JS-递归/","excerpt":"","text":"递归递归函数是在一个函数通过名字调用自身的情况下构成的。 1234567function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125; &#125; 这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。 123var anotherFactorial = factorial; factorial = null; alert(anotherFactorial(4)); //出错！ 原始函数中有对factorial的引用，将factorial=null后factorial被销毁了，所以执行这个引用后找不到。 使用arguments.callee稳妥的递归用法使用arguments.callee ，arguments是一个对应于传递给函数的参数的类数组对象，arguments.callee指向正在执行的函数指针。 1234567function factorial(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125; &#125; 但是在严格模式下，不能访问arguments.callee ，使用命名函数表达式实现。 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125; &#125;); 以上代码创建了一个名为 f() 的命名函数表达式，然后将它赋值给变量 factorial 。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"正则表达式.md","slug":"JS-正则表达式","date":"2018-03-12T12:20:40.000Z","updated":"2018-04-05T14:49:33.286Z","comments":true,"path":"2018/03/12/JS-正则表达式/","link":"","permalink":"http://yoursite.com/2018/03/12/JS-正则表达式/","excerpt":"","text":"关于正则表达式的匹配，一开始觉得很复杂，主要是因为表达式看不懂，不知道什么是匹配符，限定符，操作符，其实使用过后才发现，正则表达其实是比较简单的，具体的参考下面一篇博文，《JavaScript学习总结（八）正则表达式》里面对于概念的讲解比较详细，正则的使用主要看自己怎么去组合，想要匹配什么样的内容，很多时候，我们要用到的正则匹配，其实网上都有比较全的正则表达式，直接搜索就可以获取到。 充分利用网上的资源才是正确学习正则的途径。 我对于正则的害怕主要是因为记不住正则表达式中特殊字符，MDN有一张表格，很完整很权威，对照这张表格就可以的。要求看到特殊字符就知道是什么意思。 MDN-正则表达式 注意正则有一些字符类匹配，很多时候大家都是使用字符类匹配。这个要记住。 重复匹配符也要注意，这个也要记住，一看就能知道表达的匹配范围。 其他的东西就直接在博文上看就可以了。 下面有一个导图，记住这个导图你就理解了。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"日期格式化.md","slug":"JS-日期格式化","date":"2018-03-12T12:19:40.000Z","updated":"2018-04-05T14:49:33.499Z","comments":true,"path":"2018/03/12/JS-日期格式化/","link":"","permalink":"http://yoursite.com/2018/03/12/JS-日期格式化/","excerpt":"","text":"日期格式化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647'usestrict';/**========================================================= * 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * 例子： * (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==&gt; 2006-07-02 08:09:04.423 * (new Date()).Format(\"yyyy-M-d h:m:s.S\") ==&gt; 2006-7-2 8:9:4.18 =========================================================*/(function () &#123; Date.prototype.format = function (fmt) &#123; if (typeof(fmt) == \"undefined\") &#123; fmt = \"yyyy-MM-dd hh:mm:ss\"; &#125; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; //年份是最多表示有四位数，所以分开来处理 if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); &#125; //遍历其他的都是两位数的时间内容 for (var k in o) &#123; if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); &#125; return fmt; &#125;; Date.prototype.formatDay = function () &#123; return this.format(\"yyyy-MM-dd\"); &#125;; Date.prototype.formatDay2 = function () &#123; return this.format(\"yyyyMMddhhmmss\"); &#125;;&#125;)(); 关于这个时间格式化代码，这段厉害就厉害在于，正则表达式应用的非常炉火纯青。尤其replace那一段，使用捕获括号匹配字符串并记住字符串，用$1表示记住的第一个匹配对象，后面替换也很巧妙，设定好位数，然后字符串拼接，最重要的一步，再使用substr截取字符串，一般情况下我想的就是拼凑，先删都拼，比较好的做法是先拼后删。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"数组排序算法.md","slug":"JS-数组排序算法","date":"2018-03-12T12:18:40.000Z","updated":"2018-04-05T14:49:33.524Z","comments":true,"path":"2018/03/12/JS-数组排序算法/","link":"","permalink":"http://yoursite.com/2018/03/12/JS-数组排序算法/","excerpt":"","text":"前言以前对于排序，只知道冒泡排序，了解一点快速排序，一直是我的弱点，今天是时候好好攻克一下了参考：JS中可能用得到的全部的排序算法 时间复杂度 1、冒泡排序冒泡排序需要两个嵌套的循环. 其中, 外层循环移动游标; 内层循环遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束. 1234567// 交换下标a、b对应的数组数值，此方法抽离处理，后面直接使用，不做说明function exchange(a, b, obj) &#123; let temp = obj[a]; obj[a] = obj[b]; obj[b] = temp;// return obj&#125; 12345678910111213function sort(array) &#123; let count=0; for (let i = 0, len = array.length; i &lt; len; i++) &#123; for (let j = 0; j &lt; len; j++) &#123; if (array[i] &lt; array[j]) &#123; count++ exchange(i, j, array) &#125; &#125; &#125; //count=81 return array;&#125; 2、双向冒泡排序双向冒泡排序是冒泡排序的一个简易升级版, 又称鸡尾酒排序. 冒泡排序是从低到高(或者从高到低)单向排序, 双向冒泡排序顾名思义就是从两个方向分别排序(通常, 先从低到高, 然后从高到低). 因此它比冒泡排序性能稍好一些. 1234567891011121314151617function sort(array) &#123; for (let i = 0, len = array.length; i &lt; len; i++) &#123; for (let j = 0; j &lt; len; j++) &#123; if (array[i] &lt; array[j]) &#123; exchange(i, j, array) &#125; &#125; for (let k = len - 1; k &gt;= 0; k--) &#123; //从一个方向开始循环检查 if (array[i] &lt; array[k])&#123; exchange(i, k, array) &#125; &#125; &#125;// count=81 return array;&#125; 3、选择排序从算法逻辑上看, 选择排序是一种简单且直观的排序算法. 它也是两层循环. 内层循环就像工人一样, 它是真正做事情的, 内层循环每执行一遍, 将选出本次待排序的元素中最小(或最大)的一个, 存放在数组的起始位置. 而 外层循环则像老板一样, 它告诉内层循环你需要不停的工作, 直到工作完成(也就是全部的元素排序完成).Tips: 选择排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 比如数组[2,2,1,3], 正向排序时, 第一个数字2将与数字1交换, 那么两个数字2之间的顺序将和原来的顺序不一致,虽然它们的值相同, 但它们相对的顺序却发生了变化. 我们将这种现象称作不稳定性. 1234567891011121314/** 3、选择排序 **/function sort(array) &#123; let res = [], min; for (let i = 0, len = array.length; i &lt; len - 1; i++) &#123; //由于第一个开始跟后面对比，因此只需要对比n-1 min = i; for (let j = i + 1; j &lt; len; j++) &#123; if (array[min] &gt; array[j]) &#123; min = j //每一轮循环记下此轮最小值的下标，在后面将此下标值放到数列前面 &#125; &#125; exchange(min, i, array) &#125; return array;&#125; 插入排序插入排序的设计初衷是往有序的数组中快速插入一个新的元素. 它的算法思想是: 把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的. 插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 . 4、直接插入排序它的基本思想是: 将待排序的元素按照大小顺序, 依次插入到一个已经排好序的数组之中, 直到所有的元素都插入进去.由于直接插入排序每次只移动一个元素的位置, 并不会改变值相同的元素之间的排序, 因此它是一种稳定排序. 1234567891011121314151617/** 4、直接插入排序 **/function sort(array) &#123; for (let i = 1, len = array.length; i &lt; len; i++) &#123; //直接从第二个开始比较 let current = array[i]; //将这次要比较的值存储起来，作为这一轮循环里面的常量 let index = i; //从index前一位数开始比较比较，如果当前比较的数小于它的前一位，则将大的数后移一位 while (current &lt; array[index - 1] &amp;&amp; index &gt;= 0) &#123; array[index] = array[index - 1]; index--; //于此同时，下标也前移一位，继续下一次比较 &#125; if (index !== i) &#123; //防止自己赋值给自己， array[index] = current //如果不是自己，则一定是之前后移空出来留给current的位置，插入进去 &#125; &#125; return array;&#125; 5、折半插入排序折半插入排序是直接插入排序的升级版. 鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可. 说白一点就是从第二个数开始向前比较，前面的数（已经排好序）分成两半，找到中间的数，比较大小，然后在向中间循环，一直找到介于两者之间的，然后把之后的后移，将此值插入到后移留出来的位置。 和直接插入法相比，少了一半数据量的对比。 算法基本思想是: 取0 ~ i-1的中间点( m = (i-1)&gt;&gt;1 ), array[i] 与 array[m] 进行比较, 若array[i] &lt; array[m] , 则说明待插入的元素array[i] 应该处于数组的 0 ~ m 索引之间; 反之, 则说明它应该处于数组的 m ~ i-1 索引之间. 重复步骤1, 每次缩小一半的查找范围, 直至找到插入的位置. 将数组中插入位置之后的元素全部后移一位. 在指定位置插入第 i 个元素. 12345678910111213141516171819202122232425/** 5、折半插入排序 **/function sort(array) &#123; for (let i = 1, len = array.length; i &lt; len; i++) &#123; //直接从第二个开始比较 i=1 let low = 0, high = i - 1, current = array[i]; //找中值对应的下标 while (low &lt;= high) &#123;// let m = Math.floor((low+high) / 2); let m = (low + high) &gt;&gt; 1; //x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) . if (array[i] &lt;= array[m]) &#123; high = m - 1 //保证low&lt;=high顺利成立，将high定位低半区 &#125; else &#123; low = m + 1 //同理 &#125; &#125; //将在要插入值位置之后的所有元素后移，留出插入的位置 for (let j = i; j &gt; low; j--) &#123; array[j] = array[j - 1]; console.log(array) &#125; array[low] = current //插入 &#125; return array;&#125; 6、希尔排序希尔排序也称缩小增量排序, 它是直接插入排序的另外一个升级版, 实质就是分组插入排序. 希尔排序以其设计者希尔(Donald Shell)的名字命名, 并于1959年公布. 算法的基本思想: 将数组拆分为若干个子分组, 每个分组由相距一定”增量”的元素组成. 比方说将[0,1,2,3,4,5,6,7,8,9,10]的数组拆分为”增量”为5的分组, 那么子分组分别为 [0,5], [1,6], [2,7], [3,8], [4,9] 和 [5,10]. 然后对每个子分组应用直接插入排序. 逐步减小”增量”, 重复步骤1,2. 直至”增量”为1, 这是最后一个排序, 此时的排序, 也就是对全数组进行直接插入排序. 示意图： 可见, 希尔排序实际上就是不断的进行直接插入排序, 分组是为了先将局部元素有序化. 因为直接插入排序在元素基本有序的状态下, 效率非常高. 而希尔排序呢, 通过先分组后排序的方式, 制造了直接插入排序高效运行的场景. 因此希尔排序效率更高. 123456789101112131415161718192021222324252627282930313233/** 6、希尔排序 **///封装直接插入排序function dirSort(array, grap) &#123; grap = arguments[1] ? grap : 1; //如果grap传值了，则为grap传入的值，如果没有，则从1开始// debugger; for (let i = grap - 1, len = array.length; i &lt; len; i++) &#123; //直接从第grap-1个开始比较 let current = array[i]; //将这次要比较的值存储起来，作为这一轮循环里面的常量 let index = i; //只比较分组内的最大步长间距的两个数，循环一次就跳出来 while (current &lt; array[index - grap] &amp;&amp; index &gt;= 0) &#123; array[index] = array[index - grap]; //如果当前比较的数小于它的前一位，则将大的数后移一位 index -= grap; //于此同时，下标也前移grap，继续下一次比较 &#125; if (index !== i) &#123; //防止自己赋值给自己， array[index] = current; //如果不是自己，则一定是之前后移空出来留给current的位置，插入进去 console.log(array)// debugger &#125; &#125; return array;&#125;function sort(array) &#123; let gra = array.length &gt;&gt; 1; while (gra &gt; 0) &#123; dirSort(array, gra); gra = gra &gt;&gt; 1; &#125; return array&#125; 7、快速排序这是一种使用非常广泛的排序，典型的代表就是Chrome的v8引擎为了高效排序, 在排序数据超过了10条时, 便会采用快速排序. 对于10条及以下的数据采用的便是插入排序 快速排序”的思想很简单，整个排序过程只需要三步：（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 123456789101112131415161718192021/** 7、快速排序 **/function sort(array) &#123; if (array.length &gt;= 1) &#123; //选取基准点，基准点选取的好坏决定了排序速度的好坏，目前没有好的方法，一般居中选取 let baseIndex = array.length &gt;&gt; 1; let left = [], right = []; //定义基准点左右两边数组，小的都在左边，大的都在右边 // 循环判断 for (let i = 0; i &lt; array.length; i++) &#123; if (i !== baseIndex) &#123; //这一步很关键，一定不能把自身算进去 if (array[i] &lt; array[baseIndex]) &#123; left.push(array[i]) &#125; else right.push(array[i]) &#125; &#125;// 最关键的一步：递归调用然后在用数组拼接 return arguments.callee(left).concat(array[baseIndex], arguments.callee(right)) &#125; else return array;&#125; 8、归并排序归并排序建立在归并操作之上, 它采取分而治之的思想, 将数组拆分为两个子数组, 分别排序, 最后才将两个子数组合并; 拆分的两个子数组, 再继续递归拆分为更小的子数组, 进而分别排序, 直到数组长度为1, 直接返回该数组为止. 123456789101112131415161718192021222324/** 8、归并排序 **/function sort(array) &#123; if (array.length &lt; 2) return array; else &#123; let res = []; //上半部分拆分数组， let baseIndex = array.length &gt;&gt; 1; let left = array.slice(0, baseIndex), right = array.slice(baseIndex); //合并数组， function merge(left, right) &#123; while (left.length &amp;&amp; right.length) &#123; let item = left[0] &lt;= right[0] ? left.shift() : right.shift(); res.push(item); &#125; return res.concat(left.length ? left : right); //返回排好数组 &#125; //递归调用，一边拆分，一边合并 return merge(arguments.callee(left), arguments.callee(right)); &#125;&#125; 9、堆排序10、计数排序计数排序利用了一个特性, 对于数组的某个元素, 一旦知道了有多少个其它元素比它小(假设为m个), 那么就可以确定出该元素的正确位置(第m+1位) 获取待排序数组A的最大值, 最小值. 将最大值与最小值的差值+1作为长度新建计数数组B，并将相同元素的数量作为值存入计数数组. 对计数数组B累加计数, 存储不同值的初始下标. 从原数组A挨个取值, 赋值给一个新的数组C相应的下标, 最终返回数组C. 11、桶排序桶排序即所谓的箱排序, 它是将数组分配到有限数量的桶子里. 每个桶里再各自排序(因此有可能使用别的排序算法或以递归方式继续桶排序). 当每个桶里的元素个数趋于一致时, 桶排序只需花费O(n)的时间. 桶排序通过空间换时间的方式提高了效率, 因此它需要额外的存储空间(即桶的空间). 12、基数排序基数排序源于老式穿孔机, 排序器每次只能看到一个列. 它是基于元素值的每个位上的字符来排序的. 对于数字而言就是分别基于个位, 十位, 百位 或千位等等数字来排序. (不明白不要紧, 我也不懂, 请接着往下读)","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"找最大值、重复元素.md","slug":"JS-数组、字符串中最大、重复元素查找","date":"2018-03-08T12:17:40.000Z","updated":"2018-04-05T14:49:33.365Z","comments":true,"path":"2018/03/08/JS-数组、字符串中最大、重复元素查找/","link":"","permalink":"http://yoursite.com/2018/03/08/JS-数组、字符串中最大、重复元素查找/","excerpt":"","text":"一维数组中寻找最大值let array=[……] 1、for循环遍历for循环是最直接的方法，但也是时间复杂度最高的方法。O(n) 123456let array = [5, 7, 89, 2, 4]let max = array[0];for (let i = 0; i &lt; array.length; i++) &#123; max = (max &gt;= array[i]) ? max : array[i];&#125;console.log(max); //89 2、Math.max推荐的方法，但是要注意Math.max()对象中传递的单个参数，不能传递整个数组，此时便需要用apply方法将数据对象转化为单个参数对象。这种算法的时间负责度为多少？？ 123let array = [5, 7, 89, 2, 4]let max = Math.max.apply(array, array);console.log(max); //89 但是在ES6中，有一个新的API，扩展运算符…，将一个数组转为用逗号分隔的参数序列，所以上式还有一个更简单的替代apply的方法 1let max = Math.max(...array) 顺便可以区分一下apply、call、bind之间的区别。call传递的是单个参数：call(this,arg1,arg2,arg3...)apply可以传递的是一个数组: apply(this,arguments[])bind只传递一个对象:bind(this) 3、Array.sort()排序之后再取最后一位这个办法的时间复杂度就是视具体浏览器JS引擎以及数组长度而定了。 123let array = [5, 7, 89, 2, 4]let newArr= array.sort();console.log(newArr[newArr.length-1]); //89 一维数组寻找重复率最高的元素使用hash让object.key=元素，value=出现次数，遍历对象，找到value中最大值，然后将对应的key值返回就好了 123456789101112131415161718192021222324//找出数组中出现最多的元素let arr = ['a', 'b', 'c', 'a', 'a', 'b'];let res = &#123;&#125;;//遍历数组，生成keysfor (let i = 0; i &lt; arr.length; i++) &#123; if (!res[arr[i]]) &#123; res[arr[i]] = 1 &#125; else &#123; res[arr[i]]++; &#125;&#125;//遍历对象，找出最大的值//这里使用Object.keys遍历let keys = Object.keys(res);let maxNum = 0, max;for (let i = 0; i &lt; keys.length; i++) &#123; if (maxNum &lt; res[keys[i]]) &#123; maxNum = res[keys[i]]; max = keys[i] &#125;&#125;console.log(max) 使用空间换时间找到找到字符串中出现频率最高的字符这个问题和在数组中寻找出现频率最高的元素其实是同一个问题，区别在于，一个是字符，一个是数组。遍历的方式不一样而已。 对于for循环遍历，字符串具有length属性，上面的方法完全适用。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"同源策略到前端跨域.md","slug":"JS-同源策略到前端跨域","date":"2018-03-08T12:16:40.000Z","updated":"2018-04-05T14:49:33.427Z","comments":true,"path":"2018/03/08/JS-同源策略到前端跨域/","link":"","permalink":"http://yoursite.com/2018/03/08/JS-同源策略到前端跨域/","excerpt":"","text":"同源策略到前端跨域前言：之前学习源生ajax时，遇到过ajax跨越问题，当时看红宝书知道CROS解决，一直在前端设置，不成功，一直以为是我哪里没有设置好，到后面才发现其实这个解决是需要在服务器端返回信息里面添加返回头Response Header，让浏览器允许访问跨域资源。实际上， 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求。后面看了路易斯的ajax知识体系又知道了有关ajax跨域还有其他的跨域解决方案，我以为我懂了，但是都没有去验证，直到过了一段时间，再看到这篇博文以及路易斯关于同源策略到前端跨域这边文章时，自己对跨域的了解其实很片面。今天好好总结一下有关跨域的整个由来以及解决方案。 同源策略同源策略 (Same-Origin Policy) 最早由 Netscape 公司提出, 所谓同源就是要求, 域名, 协议, 端口相同. 非同源的脚本不能访问或者操作其他域的页面对象(如DOM等). 作为著名的安全策略, 虽然它只是一个规范, 并不强制要求, 但现在所有支持 javaScript 的浏览器都会使用这个策略. 以至于该策略成为浏览器最核心最基本的安全功能, 如果缺少了同源策略, web的安全将无从谈起. 网上的一个栗子：相对 http://store.company.com/dir/page.html 同源检测的示例: URL 结果 原因 http://store.company.com/dir/inner/another.html 成功 同一域名 http://store.company.com/dir2/other.html 成功 同一域名下不同文件夹 https://store.company.com/secure.html 失败 不同的协议 ( https ) http://store.company.com:81/dir/etc.html 失败 不同的端口 ( 81 ) http://news.company.com/dir/other.html 失败 不同的主机 ( news ) 同源策略要求三同, 即:同域,同协议,同端口. 同域即host相同, 顶级域名, 一级域名, 二级域名, 三级域名等必须相同, 且域名不能与 ip 对应; 同协议要求, http与https协议必须保持一致; 同端口要求, 端口号必须相同. 在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。 跨域访问关于解决跨域访问的方法， 一共收集到以下几种，CROS，取消浏览器安全校验，JSONP实际操作过，其他的方法来源于网络，并没有验证。 1、主域相同的跨域1.1、document.domain document.domain的场景只适用于不同子域的框架间的交互，及主域必须相同的不同源。 通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信(即它们必须在同一个一级域名下). 同域策略认为域和子域隶属于不同的域，比如a.com和 script.a.com是不同的域，这时，我们无法在a.com下的页面中调用script.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。 比如, 我们在 www.a.com/a.html 下, 现在想获取 www.script.a.com/b.html, 即主域名相同, 二级域名不同. 那么可以这么做: 12345678910document.domain = 'a.com';var iframe = document.createElement('iframe');iframe.src = 'http://www.script.a.com/b.html';iframe.style.display = 'none';document.body.appendChild(iframe);iframe.addEventListener('load',function()&#123; //TODO 载入完成时做的事情 //var _document = iframe.contentWindow.document; //...&#125;,false); 注：浏览器单独保存端口号。任何的赋值操作，包括document.domain = document.domain都会以null值覆盖掉原来的端口号。因此，赋值时必须带上端口号，确保端口号不会为null. 2、完全不同源的跨域（两个页面之间的通信）2.1 通过location.hash跨域假设域名a.com下的文件cs1.html要和jianshu.com域名下的cs2.html传递信息。1、cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向jianshu.com域名下的cs2.html页面。2、cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据。3、同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值。 注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe。 优点：1.可以解决域名完全不同的跨域。2.可以实现双向通讯。缺点：location.hash会直接暴露在URL里，并且在一些浏览器里会产生历史记录，数据安全性不高也影响用户体验。另外由于URL大小的限制，支持传递的数据量也不大。有些浏览器不支持onhashchange事件，需要轮询来获知URL的变化。 2.2通过window.name跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。 123window.name = data;//父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入。 location = &apos;http://parent.url.com/xxx.html&apos;;//接着，子窗口跳回一个与主窗口同域的网址。var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name。//然后，主窗口就可以读取子窗口的window.name了。 如果是与iframe通信的场景就需要把iframe的src设置成当前域的一个页面地址。 这个方式非常适合单向的数据请求，而且协议简单、安全. 不会像JSONP那样不做限制地执行外部脚本. 2.3、通过window.postMessage跨域ES5新增的 postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递. 语法: postMessage(data,origin) data: 要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候建议使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果. origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 父窗口和子窗口都可以通过message事件，监听对方的消息。message事件的事件对象event，提供以下三个属性： 1、event.source：发送消息的窗口。 2、event.origin： 消息发向的网址。 3、event.data：消息内容。 父页面发送消息: 1window.frames[0].postMessage('message', origin) iframe接受消息: 1234window.addEventListener('message',function(e)&#123; if(e.source!=window.parent) return;//若消息源不是父页面则退出 //TODO ...&#125;); 2.4、Access Control此跨域方法目前只在很少的浏览器中得以支持, 这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现, IE8下通过XDomainRequest实现）, 请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头, 该响应头声明了请求域的可访问权限. 例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax）, 那么getUsers.php必须加入如下的响应头: 1header(\"Access-Control-Allow-Origin: http://www.baidu.com\");//表示允许baidu.com跨域请求本文件 2.5、flash URLLoderflash有自己的一套安全策略, 服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问, SWF也可以通过API来确定自身能被哪些域的SWF加载. 当跨域访问资源时, 例如从域 a.com 请求域 b.com上的数据, 我们可以借助flash来发送HTTP请求. 首先, 修改域 b.com上的 crossdomain.xml(一般存放在根目录, 如果没有需要手动创建) , 把 a.com 加入到白名单; 12345&lt;?xml version=\"1.0\"?&gt;&lt;cross-domain-policy&gt;&lt;site-control permitted-cross-domain-policies=\"by-content-type\"/&gt;&lt;allow-access-from domain=\"a.com\" /&gt;&lt;/cross-domain-policy&gt; 其次, 通过Flash URLLoader发送HTTP请求, 拿到请求后并返回; 最后, 通过Flash API把响应结果传递给JavaScript. Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了. 2.6、使用代理虽然ajax和iframe受同源策略限制, 但服务器端代码请求, 却不受此限制, 我们可以基于此去伪造一个同源请求, 实现跨域的访问. 如下便是实现思路: 请求同域下的web服务器; web服务器像代理一样去请求真正的第三方服务器; 代理拿到数据过后, 直接返回给客户端ajax. 这样, 我们便拿到了跨域数据. 但是这种方法成本高，操作麻烦，不推荐 3、Ajax请求不同源的跨域跨域3.1、通过CROS跨域CORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外) 简而言之, 浏览器不再一味禁止跨域访问, 而是检查目的站点的响应头域, 进而判断是否允许当前站点访问. 通常, 服务器使用以下的这些响应头域用来通知浏览器: Access-Control-Allow-Origin: 指定允许哪些源的网页发送请求. Access-Control-Allow-Credentials: 指定是否允许cookie发送. Access-Control-Allow-Methods: 指定允许哪些请求方法. Access-Control-Allow-Headers: 指定允许哪些常规的头域字段, 比如说 Content-Type. Access-Control-Expose-Headers: 指定允许哪些额外的头域字段, 比如说 X-Custom-Header. Access-Control-Max-Age: 指定preflight OPTIONS请求的有效期, 单位为秒. CORS请求分为两种, ① 简单请求; ② 非简单请求.满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客) 1) 请求是以下三种之一: HEAD GET POST 2) http头域不超出以下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type字段限三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 3.1.1 简单请求浏览器将发送一次http请求, 同时在Request头域中增加 Origin 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 Access-Control-_ 等字段._ 一个栗子：假如站点 http://foo.example 的网页应用想要访问 http://bar.other 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行： 12345678910//foo.examplevar invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/public-data/';function callOtherDomain() &#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 1234567891011121314151617181920212223//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.example //该请求来自于 http://foo.exmaple。//以上是浏览器发送请求HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61 Access-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为http://foo.example。其它站点就不能跨站访问 http://bar.other 的资源了。Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml//以上是服务器返回信息给浏览器 通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过服务器需要把 Access-Control-Allow-Origin 设置为 * 或者包含由 Origin 指明的站点。 3.1.2 非简单请求(预请求)当请求具备以下条件，就会被当成预请求（非简单请求）处理： （1）请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。 （2）使用自定义请求头（比如添加诸如 X-PINGOTHER）对于非简单请求，浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 Access-Control-* 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发). 一个例子：使用了自定义请求头的非简单请求 123456789101112var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/post-here/';var body = '&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;Arun';function callOtherDomain()&#123; if(invocation)&#123; invocation.open('POST', url, true); invocation.setRequestHeader('X-PINGOTHER', 'pingpong'); invocation.setRequestHeader('Content-Type', 'application/xml'); invocation.onreadystatechange = handler; invocation.send(body); &#125;&#125; 以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。浏览器使用一个 OPTIONS 发送了一个“预请求”。 假设服务器成功响应返回部分信息如下： 1234Access-Control-Allow-Origin: http://foo.example //表明服务器允许http://foo.example的请求Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法Access-Control-Allow-Headers: X-PINGOTHER //传递一个可接受的自定义请求头列表。服务器也需要设置一个与浏览器对应。否则会报 Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response 的错误Access-Control-Max-Age: 1728000 //告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。 3.1.3 附带凭证信息的请求XMLHttpRequest 和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将 XMLHttpRequest 的一个特殊标志位withCredentials设置为true，浏览器就将允许该请求的发送。 1234567891011//http://foo.example站点的脚本向http://bar.other站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/';function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 第七行代码将 XMLHttpRequest 的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials： true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。 假设服务器成功响应返回部分信息应该如下： 123Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Credentials: trueSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT 如果bar.other的响应头里没有Access-Control-Allow-Credentials：true，则响应会被忽略.。 特别注意: 给一个带有withCredentials的请求发送响应的时候，服务器端必须指定允许请求的域名,不能使用“*”。上面这个例子中，如果响应头是这样的 Access-Control-Allow-Origin：* ，则响应会失败。 3.2、 JSONP跨域基本原理：网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。例子如下： 123456789function todo(data)&#123; console.log('The author is: '+ data.name);&#125;var script = document.createElement('script');script.src = 'http://www.jianshu.com/author?callback=todo';//向服务器www.jianshu.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字。document.body.appendChild(script);//服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。todo(&#123;\"name\": \"fewjq\"&#125;);//由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了todo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象。 优点：简单适用，老式浏览器全部支持，服务器改造小。不需要XMLHttpRequest或ActiveX的支持。 缺点：只支持GET请求。 3.3、WebSocket跨域WebSocket 本质上是一个基于TCP的协议, 它的目标是在一个单独的持久链接上提供全双工(full-duplex), 双向通信, 以基于事件的方式, 赋予浏览器实时通信能力. 既然是双向通信, 就意味着服务器端和客户端可以同时发送并响应请求, 而不再像HTTP的请求和响应. (同源策略对 web sockets 不适用) 原理: 为了建立一个WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求, 这个请求和通常的HTTP请求不同, 包含了一些附加头信息, 其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求, 服务器端解析这些附加的头信息然后产生应答信息返回给客户端, 客户端和服务器端的WebSocket连接就建立起来了, 双方就可以通过这个连接通道自由的传递信息, 并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接. 3.4、Comet跨域在WebSocket出现之前, 很多网站为了实现实时推送技术, 通常采用的方案是轮询(Polling)和Comet技术, Comet又可细分为两种实现方式, 一种是长轮询机制, 一种称为流技术, 这两种方式实际上是对轮询技术的改进, 这些方案带来很明显的缺点, 需要由浏览器对服务器发出HTTP request, 大量消耗服务器带宽和资源. 面对这种状况, HTML5定义了WebSocket协议, 能更好的节省服务器资源和带宽并实现真正意义上的实时推送. 3.5、图像ping跨域图像ping跨域请求技术是使用 &lt;img&gt; 标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。 图像ping有两个主要的缺点，1、只能发送GET请求；2、无法访问服务器相应文本 3.6、浏览器解除安全控制，允许跨域在实际开发过程中，有时候经常遇到这样一种情况：开发过程中会涉及到跨域问题，前端需要向服务请求某个接口，但是由于不同源，浏览器拦截响应，在上线之后项目便在同一个源，这种情况为了快速开发，可以将浏览器安全检查关闭，允许获取跨域资源。禁止浏览器跨域安全检查（这里以chrome为例） 1&quot;C:\\Users\\UserName\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe&quot; --disable-web-security --user-data-dir Chrome 跨域 disable-web-security 关闭安全策略 文章参考摘录来源：前端跨域问题及解决方案路易斯-《由同源策略到前端跨域》路易斯-《ajax知识大梳理》","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"一些常用的JS方法.md","slug":"JS-一些常用的JS方法","date":"2018-03-05T12:10:40.000Z","updated":"2018-04-05T14:49:33.564Z","comments":true,"path":"2018/03/05/JS-一些常用的JS方法/","link":"","permalink":"http://yoursite.com/2018/03/05/JS-一些常用的JS方法/","excerpt":"","text":"filter() 方法实例javascript filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。 1arr.filter(callback,[ thisArg]) indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。语法 1stringObject.indexOf(searchvalue,fromindex) assign() 方法assign() 方法可加载一个新的文档。 1location.assign(URL) Object.assign()方法特点：浅拷贝、对象属性的合并 var nObj = Object.assign({},obj,obj1);//花括号叫目标对象，后面的obj、obj1是源对象。对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的 文件流转BinaryString12345678910//文件流转BinaryString function fixdata(data) &#123; var o = \"\", l = 0, w = 10240; for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w))); o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w))); return o; &#125; unshift() 方法unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。语法： 1arrayObject.unshift(newelement1,newelement2,....,newelementX) 参数 描述newelement1 必需。向数组添加的第一个元素。newelement2 可选。向数组添加的第二个元素。newelementX 可选。可添加若干个元素。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JS引擎-以V8为例.md","slug":"JS-JS引擎","date":"2018-03-05T06:05:40.000Z","updated":"2018-04-05T14:49:33.448Z","comments":true,"path":"2018/03/05/JS-JS引擎/","link":"","permalink":"http://yoursite.com/2018/03/05/JS-JS引擎/","excerpt":"","text":"同步：一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。异步：进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。进程：狭义上，就是正在运行的程序的实例。广义上，进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。线程：线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位。指运行中的程序的调度单位。单线程：单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。单线程就是进程里只有一个线程。多线程：在单个程序中同时运行多个线程完成不同的工作，称为多线程。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"JS实现深度复制.md","slug":"JS-JS-deep-clone","date":"2018-03-05T04:05:40.000Z","updated":"2018-04-05T14:47:26.479Z","comments":true,"path":"2018/03/05/JS-JS-deep-clone/","link":"","permalink":"http://yoursite.com/2018/03/05/JS-JS-deep-clone/","excerpt":"","text":"JS深复制是在阿里一面的过程中遇到的，以前都不知道，所以当时一脸懵逼，回来赶紧google，发现邹大大以前写过关于深复制的实现，这里参考他的文章：深入剖析 JavaScript 的深复制 浅复制复制的是存在栈内存里面的引用指针，并不是存放在堆内存中的内容，当对一个对象下面的属性值进行修改时，所有的都会变化。 12345678910/** 浅复制 **/let person1 = &#123; 'name': 'Jack', 'age': 29&#125;;let person2 = person1;person2.name = \"Kai\";console.log(person1.name); //'Kai'console.log(person2.name); //'Kai' 深复制深复制想实现把对象里面属性值也给复制，当修改复制后的对象某个属性值时，原对象对应的属性值不会被修改。 实现方法 JSON的全局对象parse和stringify方法。 jQuery的$.clone() 和 $.extend()方法。 Underscored的_.clone() lodash的_.clone() / _.cloneDeep() 邹润阳建议的拥抱未来的深复制方法，直接定义在prototype上面。 JSON的全局对象parse和stringify方法。123function deepClone(source)&#123; return JSON.parse(JSON.stringify(source));&#125; 例子： 1234567891011/** 深复制 **/let person1 = &#123; 'name': 'Jack', 'age': 29&#125;;let person2 = JSON.parse(JSON.stringify(person1));person2.name = \"Kai\";console.log(person1.name); //'Jack'console.log(person2.name); //'Kai' 上面这种方法好处是非常简单易用,，对于Number, String,Obejct等来说基本实现。但是坏处也显而易见,对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor，也就是深复制之后，无论这个对象原本的构造函数是什么，在深复制之后都会变成Object。 1234567891011121314151617/** 深复制 **/let person1 = &#123; 'name': 'Jack', 'age': 29, 'fn':function ()&#123; console.log('fn') &#125;, 'reg':new RegExp('e')&#125;;let person2 = JSON.parse(JSON.stringify(person1));person2.name = \"Kai\";console.log(person1.name); //'Jack'console.log(person2.name); //'Kai'console.log(person2.fn); //undefinedconsole.log(person2.reg); //Object jQuery Underscored lodash第三方插件实现现在不做介绍，以后用的的时候再补充进来 邹润阳–拥抱未来的深复制方法","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Javascript编程风格.md","slug":"JS-Javascript编程风格","date":"2018-03-04T17:15:40.000Z","updated":"2018-04-05T14:47:26.468Z","comments":true,"path":"2018/03/05/JS-Javascript编程风格/","link":"","permalink":"http://yoursite.com/2018/03/05/JS-Javascript编程风格/","excerpt":"","text":"来源：《Javascript编程风格》大括号规则1：表示区块起首的大括号，不要另起一行。 圆括号规则2：调用函数的时候，函数名与左括号之间没有空格。 规则3：函数名与参数序列之间，没有空格。 规则4：所有其他语法元素与左括号之间，都有一个空格。 分号规则5：不要省略句末的分号。 with语句规则6：不要使用with语句。 ==与===规则7：不要使用”相等”（==）运算符，只使用”严格相等”（===）运算符。 语句的合并规则8：不要将不同目的的语句，合并成一行。尤其是赋值语句。 变量声明规则9：所有变量声明都放在函数的头部。 规则10：所有函数都在使用之前定义。 全局变量规则11：避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如UPPER_CASE。 new命令规则12：不要使用new命令，改用Object.create()命令。 规则13：建构函数的函数名，采用首字母大写（InitialCap）；其他函数名，一律首字母小写。 自增和自减运算符规则14：不要使用自增（++）和自减（–）运算符，用+=和-=代替。 区块规则15：总是使用大括号表示区块。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"this对象.md","slug":"JS-this对象","date":"2018-02-05T12:09:40.000Z","updated":"2018-04-05T14:49:33.341Z","comments":true,"path":"2018/02/05/JS-this对象/","link":"","permalink":"http://yoursite.com/2018/02/05/JS-this对象/","excerpt":"","text":"参考：阮一峰《Javascript的this用法》 追梦子《彻底理解js中this的指向，不必硬背》 1、纯粹的函数调用与作为对象方法的调用this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。这句话并不完全对，但是大多数时候可以用这种方法去判断this指向。 一般情况下，this指向全局对象window，因为是全局window调用 这里的a()是由window.a()调用的，所以this指向window 123456function a()&#123; var user = \"追梦子\"; console.log(this.user); //undefined console.log(this); //Window&#125;a(); 通过其他对象调用，this指向调用对象 1234567var o = &#123; user:\"追梦子\", fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;o.fn(); 这里 fn()中的this由对象o调用，则this指向对象o。 如有多层对象，this指向它上一级的对象。 12345678910var o = &#123; a:10, b:&#123; // a:12, fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 此时this指向上一级队形b而不是指向对象o。 总结起来三种情况： 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 一个特殊的例子 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 这里的this并没有指向对象b，而是window，因为最后的调用是window.j()。 作为纯粹的函数调用其实就是window调用，其this对象指向window，改变的欧式全局属性 作为对象方法调用，this就指向这个上级对象。 2、构造函数中的this12345function Fn()&#123; this.user = \"追梦子\";&#125;var a = new Fn();console.log(a.user); //追梦子 这里这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。 为什么this会指向a？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代 3、使用apply() call() bind() 改变this指向掌握三种方法的用法，了解三种方法的区别即可call传递的是单个参数：call(this,arg1,arg2,arg3...)apply可以传递的是一个数组: apply(this,arguments[])bind只传递一个对象:bind(this) 几种特殊的情况1、当this遇到return时如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例 请看例子 123456789function fn() &#123; this.user = '追梦子'; return &#123;&#125;; //或者 //return function()&#123;&#125;;&#125;var a = new fn; console.log(a.user); //undefined 12345678function fn() &#123; this.user = '追梦子'; return 1; //或者undefined &#125;var a = new fn; console.log(a.user); //追梦子 又一个特殊的情况 1234567function fn() &#123; this.user = '追梦子'; return null;&#125;var a = new fn; console.log(a.user); //追梦子 null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 2、闭包中的this对象闭包的执行环境具有全局性，所以在闭包中，this一般指向window","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"String对象.md","slug":"JS-String对象","date":"2018-01-05T12:08:40.000Z","updated":"2018-04-05T14:49:33.473Z","comments":true,"path":"2018/01/05/JS-String对象/","link":"","permalink":"http://yoursite.com/2018/01/05/JS-String对象/","excerpt":"","text":"JavaScript String对象参考：JavaScript字符串所有API全解密 String 对象属性 属性 描述 constructor 对创建该对象的函数的引用 length 字符串的长度 prototype 允许您向对象添加属性和方法 String 对象方法 方法 描述 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 fromCharCode() 将 Unicode 编码转为字符。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 trim() 去除字符串两边的空白 concat() 连接两个或更多字符串，并返回新的字符串。如果有多个空格，则视为一个 indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。 lastIndexOf() 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 search() 查找与正则表达式相匹配的值。 match() 查找找到一个或多个正则表达式的匹配。这个蛮有用 replace() 在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。 split() 把字符串分割为字符串数组。注意参数为负的情况 slice(start,end) 提取字符串的片断，并在新的字符串中返回被提取的部分。 substr(start,length) 从起始索引号提取字符串中指定数目的字符。 substring(from , to) 提取字符串中两个指定的索引号之间的字符。 valueOf() 返回某个字符串对象的原始值。 String HTML 包装方法 方法 描述 anchor() 创建 HTML 锚。 big() 用大号字体显示字符串。 blink() 显示闪动字符串。 bold() 使用粗体显示字符串。 fixed() 以打字机文本显示字符串。 fontcolor() 使用指定的颜色来显示字符串。 fontsize() 使用指定的尺寸来显示字符串。 italics() 使用斜体显示字符串。 link() 将字符串显示为链接。 small() 使用小字号来显示字符串。 strike() 用于显示加删除线的字符串。 sub() 把字符串显示为下标。 sup() 把字符串显示为上标。 charAtcharAt() 方法返回字符串中指定位置的字符。 语法：str.charAt(index) index 为字符串索引（取值从0至length-1），如果超出该范围，则返回空串。 charCodeAtcharCodeAt() 返回指定索引处字符的 Unicode 数值。 语法：str.charCodeAt(index)。index 为一个从0至length-1的整数。如果不是一个数值，则默认为 0，如果小于0或者大于字符串长度，则返回 NaN。 concatconcat() 方法将一个或多个字符串拼接在一起，组成新的字符串并返回。 语法：str.concat(string2, string3, …). concat 的性能表现不佳，强烈推荐使用赋值操作符（+或+=）代替 concat indexOf / lastIndexOfindexOf() 方法用于查找子字符串在字符串中首次出现的位置，没有则返回 -1。lastIndexOf 则从右往左查找，其它与前者一致 语法：str.indexOf(searchValue [, fromIndex=0])，str.lastIndexOf(searchValue [, fromIndex=0]) localeComparelocaleCompare() 方法用来比较字符串，如果指定字符串在原字符串的前面则返回负数，否则返回正数或0，其中0 表示两个字符串相同 matchmatch() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp).该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null。 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 replace 使用最多的方法该方法并不改变调用它的字符串本身，而只是返回替换后的字符串. 语法： str.replace( regexp | substr, newSubStr | function[, flags] ) 简单概括,replace拥有两个参数,第一个是需要替换的字符串或者正则表达式;第二个是新的字符串或者一个function,这样参数便有四种组合. regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. searchsearch() 方法用于测试字符串对象是否包含某个正则匹配，相当于正则表达式的 test 方法，且该方法比 match() 方法更快。如果匹配成功，search() 返回正则表达式在字符串中首次匹配项的索引，否则返回-1。 语法：str.search(regexp) sliceslice() 方法提取字符串的一部分，并返回新的字符串。该方法有些类似 Array.prototype.slice 方法。 语法：str.slice(start, end) splitsplit() 方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 substrsubstr() 方法返回字符串指定位置开始的指定数量的字符。 语法：str.substr(start[, length]) subStringsubstring() 方法返回字符串两个索引之间的子串。 语法：str.substring(indexA[, indexB])indexA、indexB 表示字符串索引，其中 indexB 可选，如果省略，则表示返回从 indexA 到字符串末尾的子串。 若 indexA == indexB，则返回一个空字符串； 若 省略 indexB，则提取字符一直到字符串末尾； 若 任一参数小于 0 或 NaN，则被当作 0； 若 任一参数大于 length，则被当作 length。 如果 indexA &gt; indexB，则 substring 的执行效果就像是两个参数调换一般 toLocaleLowerCase、toLocaleUpperCasetoLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射。而toLocaleUpperCase() 方法则是转换成大写的值。 toLowerCase 、toUpperCase这两个方法分别表示将字符串转换为相应的小写，大写形式，并返回 trimtrim() 方法清除字符串首尾的空白并返回。 includes(ES6)includes() 方法基于ECMAScript 2015（ES6）规范，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。语法：str.includes(subString [, position]) endsWith(ES6) 、startsWith(ES6)endsWith() 方法基于ECMAScript 2015（ES6）规范，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。 小结 substr 和 substring，都是两个参数，作用基本相同，两者第一个参数含义相同，但用法不同，前者可为负数，后者值为负数或者非整数时将隐式转换为0。前者第二个参数表示截取字符串的长度，后者第二个参数表示截取字符串的下标；同时substring第一个参数大于第二个参数时，执行结果同位置调换后的结果。 search方法与indexOf方法作用基本一致，都是查询到了就返回子串第一次出现的下标，否则返回-1，唯一的区别就在于search默认会将子串转化为正则表达式形式，而indexOf不做此处理，也不能处理正则。 字符串对象遍历参照各种遍历方法以及使用对象 字符串回文1str.split('').reverse().join('');","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Number对象属性及对象方法.md","slug":"JS-Number对象","date":"2018-01-05T08:05:40.000Z","updated":"2018-04-05T14:49:33.409Z","comments":true,"path":"2018/01/05/JS-Number对象/","link":"","permalink":"http://yoursite.com/2018/01/05/JS-Number对象/","excerpt":"","text":"","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Math对象属性及对象方法.md","slug":"JS-Math对象","date":"2018-01-05T07:05:40.000Z","updated":"2018-04-05T14:49:33.352Z","comments":true,"path":"2018/01/05/JS-Math对象/","link":"","permalink":"http://yoursite.com/2018/01/05/JS-Math对象/","excerpt":"","text":"Math对象属性及对象方法API参考菜鸟教程 Math对象属性语法： 1Math.Attributes E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math 对象方法 方法 描述 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。注意y在前，x在后 cos(x) 返回数的余弦。 sin(x) 返回数的正弦。 tan(x) 返回角的正切。 ceil(x) 对数进行上舍入。 floor(x) 对 x 进行下舍入。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 abs(x) 返回 x 的绝对值。 exp(x) 返回 E的x次幂指数。 log(x) 返回数的自然对数（底为e）。 pow(x,y) 返回 x 的 y 次幂。 sqrt(x) 返回数的平方根。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"深入理解原型到原型链.md","slug":"JS-js从原型到原型链","date":"2018-01-05T05:05:40.000Z","updated":"2018-04-05T14:49:33.378Z","comments":true,"path":"2018/01/05/JS-js从原型到原型链/","link":"","permalink":"http://yoursite.com/2018/01/05/JS-js从原型到原型链/","excerpt":"","text":"深入理解原型到原型链说到原型，肯定离不开对象，在JS中，关于原型对象，javaScript高级程序设计中写道： 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 上述 图述的代码如下所示，创建一个构造函数，为此构造函数添加prototype属性，person1,person2对象是Person的实例，Person上面的属性和方法共享。 1234567891011121314function Person() &#123;&#125;Person.prototype.name = 'Nicholas';Person.prototype.age=29;Person.prototype.job=\"Software Engineer\";Person.prototype.syaName=function()&#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();console.log(person1.name===person2.name) // true//此时执行两次搜索person1.sysName(); //\"Nicholas\" prototype函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们测试： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 此时我们更新关系图： 实例与原型我们在读取对象属性的时候，要注意搜索顺序， 123456789101112131415161718function Person() &#123;&#125;Person.prototype.name = 'Nicholas';Person.prototype.age=29;Person.prototype.job=\"Software Engineer\";Person.prototype.syaName=function()&#123; alert(this.name);&#125;var person1 = new Person();var person2 = new Person();person1.name='Mack';console.log(person1.name) // Mackconsole.log(person2.name) // Nicholas//此时执行两次搜索person1.sysName(); //\"Mack\" 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = &apos;Kevin&apos;console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 隐式引用（implicit reference），这个引用称之为 原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的 原型链（prototype chain）可以在浏览器控制台下一直打印自己的原型，返回的都是一样的。 在javaScripts高级程序设计中，关于原型链是这么定义的： 下面我们看一下书上实现原型链的一个例子 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();SuperType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue());console.log(instance.getSubValue()); 例子定义了两个类型：SuperType和SubType，每个类型分别有一个属性和一个方法。它们的主要区别是 SubType 继承了 SuperType ，而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。 关系图如下所示： 实际上，所有的引用类型默认都继承了Object，这个继承也是通过原型链实现的。记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.peototype。所以完整的关系如下所示： 关于理解js中原型与原型链，其实主要记住这张图就好了，对象的原型属性指向原型对象，原型对象中又有一个属性constructor又指向这个对象，因为这层关系的存在，所以，才会有原型链，进而有继承，正向来说，因为js语言中要设计继承属性，所以才会设计有这么一层关系，都知道js语言设计参考于C++、java等语言，不知道这些语言中关于继承是怎么设计的，但是js的这种设计一开始我看的很迷糊。 后面再会说一下关于对象原型的一个操作方法 原型操作查看原型es5带来了查看对象原型的方法——Object.getPrototypeOf，该方法返回指定对象的原型（也就是该对象内部属性[[Prototype]]的值）。 12console.log(Object.getPrototypeOf(&#123;&#125;))//Object.prototype es6带来了另一种查看对象原型的方法——Object.prototype.__proto__，一个对象的__proto__ 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),原型的值可以是一个对象值也可以是null(比如说Object.prototype.proto的值就是null)。 12(&#123;&#125;).__proto__&gt;&gt;&gt; Object.prototype 创建原型的方式在下面的例子中我们将对象a的[[Prototype]]指向b。 使用普通语法创建对象这是最容易被大家忽略的方法，在js中你是绕不过原型的，不经意间就创建了原型 12345678var o = &#123;a: 1&#125;;// o ---&gt; Object.prototype ---&gt; nullvar a = [];// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123;&#125;// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null 这种方法无法让a的[[Prototype]]指向b。 使用构造器创建对象构造函数就是一个普通的函数，只不过这次不是直接调用函数，而是在函数前加上new关键字。 每个函数都有一个prototype属性，通过new关键字新建的对象的原型会指向构造函数的prototype属性，所以我们可以修改构造函数的prototype属性从而达到操作对象原型的目的。 为了让b继承a，需要有一个构造函数A 12345678910var b = &#123;&#125;;function A() &#123;&#125;;A.prototype = b;var a = new A();Object.getPrototypeOf(a) === b;// true// a ---&gt; A.prototype === b 使用 Object.create 创建对象ES5带来了Object.create接口，可以让我们直接设置一个对象原型 123456var b = &#123;&#125;;var a = Object.create(b);Object.getPrototypeOf(a) === b;// true// a ---&gt; b Object.setPrototypeOfES6带来了另一个接口，可以绕过创建对象的过程，直接操作原型 1234567var a = &#123;&#125;;var b = &#123;&#125;;Object.setPrototypeOf(a, b);Object.getPrototypeOf(a) === b;// true// a ---&gt; b protoES6还带来了一个属性，通过这个属性也可以直接操作原型 1234567var a = &#123;&#125;;var b = &#123;&#125;;a.__proto__ = b;Object.getPrototypeOf(a) === b;// true// a ---&gt; b 注意这个属性在ES6规范的附录中，也就意味着不是所有的环境都会有这个属性。 使用 class 关键字ES6引入了以class语法糖，通过extends关键字我们也可以实现继承，但是无法直接操作对象的原型，而是要借助“类”，其实就是构造函数和函数的prototype属性。 123456789class B &#123;&#125;class A extends B &#123;&#125;var a = new A();Object.getPrototypeOf(a) === A.prototype;// true// a ---&gt; A.prototype === B的实例 参考文章：JavaScript深入之从原型到原型链 详解JavaScript中的原型和继承 全面理解面向对象的 JavaScript 《高程》","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"Array操作方法.md","slug":"JS-Array操作方法","date":"2017-10-05T12:05:40.000Z","updated":"2018-04-05T13:48:41.076Z","comments":true,"path":"2017/10/05/JS-Array操作方法/","link":"","permalink":"http://yoursite.com/2017/10/05/JS-Array操作方法/","excerpt":"","text":"Array对象数组属性constructor 返回创建数组对象的原型函数。 length设置或返回数组元素的个数。 prototype允许你向数组对象添加属性或方法。 Array 对象属性改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill 不会改变自身的方法一共有9个，分别为concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes。 添加修改删除等操作浅复制 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象concat() 连接两个或更多的数组，组成一个新的数组并返回。 copyWithin( )从数组的指定位置拷贝元素到数组的另一个指定位置中。 slice( start, end )将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。 fill()使用一个固定值来填充数组。 join()将数组中的所有元素连接成一个字符串，并返回这个字符串。 push() 向数组的末尾添加一个或更多元素，并返回新的长度，改变了原数组。 unshift()向数组的开头添加一个或更多元素，并返回新的长度。改变了原数组 shift() 删除数组第一个元素，并返回数组的第一个元素，会改变原数组。 splice() 从数组中添加或删除元素。会改变原数组 pop()删除数组的最后一个元素并返回删除后的元素，改变了原数组。 替换数组copyWithin(ES6)用于数组内元素之间的替换，即替换元素和被替换元素均是数组内的元素。改变了原数组 arr.copyWithin(target, start[, end = this.length]) fill(ES6)它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。改变了原数组 查询数组every() 检测数值元素的每个元素是否都符合条件。返回Boolean值。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。 some()检测数组元素中是否有元素符合指定条件。返回布尔值 findIndex() 返回符合传入测试（函数）条件的数组元素索引。同样，检测到第一个的时候，然后返回，不在执行后面的。 indexOf(item,start)搜索数组中的元素，并返回它所在的位置，如果没有，返回-1，但是不区分NaN。 lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 计算转换 reduce()将数组元素计算为一个值（从左到右）。如遇到字符串，执行字符串拼接。 reduceRight()将数组元素计算为一个值（从右到左）。 toString()把数组转换为字符串，并返回结果。 toLocaleString()把数组使用头LocaleString方法转换为字符串，并返回结果。 valueOf()返回数组对象的原始值。 排序reverse()反转数组的元素顺序，该方法返回对数组的引用，会改变原数组。 sort( )1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192语法：`arr.sort([comparefn])`comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode\\(万国码\\)位点顺序排序。##### 遍历方法12个1、**forEach**[`forEach(function(currentValue,index,arr),thisArg)`](http://www.runoob.com/jsref/jsref-foreach.html) 数组每个元素都执行一次回调函数。* value 当前正在被处理的元素的值，index 当前元素的数组索引，array 数组本身* thisArg 可选，用来当做fn函数内的this对象。2、**every**使用传入的函数测试所有元素，只要其中有一个函数返回值为 false，那么该方法的结果为 false；如果全部返回 true，那么该方法的结果才为 true。3、**some**some 测试数组元素时，只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false。4、**filter**filter() 方法使用传入的函数测试所有元素，并**返回所有通过测试的元素组成的新数组**。它就好比一个过滤器，筛掉不符合条件的元素。语法：`arr.filter(fn, thisArg)`5、**map**[`map()`](#)通过指定函数处理数组的每个元素，并返回处理后的**新数组**。语法：`arr.map(fn, thisArg)`6、**reduce**reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。语法：`arr.reduce(fn, initialValue)`fn 表示在数组每一项上执行的函数，接受四个参数：* `previousValue` 上一次调用回调返回的值，或者是提供的初始值* `value` 数组中当前被处理元素的值* `index` 当前元素在数组中的索引* `array` 数组自身`initialValue` 指定第一次调用 fn 的第一个参数。当 fn 第一次执行时：* 如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 将等于 initialValue，此时 item 等于数组中的第一个值；* 如果 initialValue 未被提供，那么 previousVaule 等于数组中的第一个值，item 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。* 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么fn不会被执行，数组的唯一值将被返回。7、**reduceRight**数组中的每个值（从右至左）开始合并，最终为一个值8、**entries(ES6)**返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。9、**find&amp;findIndex(ES6)**find() 方法基于ECMAScript 2015（ES6）规范，返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回undefined。findIndex() 方法也基于ECMAScript 2015（ES6）规范，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。语法：`arr.find(fn, thisArg)`，`arr.findIndex(fn, thisArg)`10、**keys(ES6)**返回一个数组索引的迭代器。11、**values(ES6)**返回一个数组迭代器对象，该对象包含数组中每个索引的值。12、**Symbol.iterator(ES6)**###小结：1. Array.prototype本身就是一个数组，并且它的长度为0。2. 所有插入元素的方法, 比如 push、unshift，一律返回数组新的长度；3. 所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组；4. 部分遍历方法，比如 forEach、every、some、filter、map、find、findIndex，它们都包含function(value,index,array)&#123;&#125; 和 thisArg 这样两个形参。5. Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性。它们不止可以用来处理数组对象，还可以处理类数组对象。#### Array.of （构造函数）`Array.of`用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其它，它基本上与Array构造器功能一致，唯一的区别就在单个数字参数的处理上.```jsArray.of(8.0); // [8]Array(8.0); // [undefined × 8] Array.from （构造函数）只要一个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。语法：Array.from(arrayLike[, processingFn[, thisArg]])Array.from拥有3个形参，第一个为类似数组的对象，必选。第二个为加工函数，新生成的数组会经过该函数的加工再返回。第三个为this作用域，表示加工函数执行时this的值。后两个参数都是可选的。注意:一旦使用加工函数，必须明确指定返回值，否则将隐式返回undefined，最终生成的数组也会变成一个只包含若干个undefined元素的空数组。 Array.isArray()判定一个对象是数组的五种方法，前四种都不保险，如果将某个对象的对象的__proto__属性为Array.prototype，便导致了该对象继承了Array对象，前四种方法就会判定为true. 1234567891011var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === '[object Array]'; 所以严格意义上判定一个对象是否是数组，推荐使用第五种方法，再说到Array.isArray()，实际上就是推荐使用的第五种toString方法。 典型问题： 数组去重实际上有很多种方法，其实都大同小异，只要熟悉数组操作的API方法，你就可以写出很多种，但是本质都是一样的。优先推荐使用ES6中Set属性不重复的特征去重。 两层for循环，一层遍历数组，一层循环对比，对相同的元素从数组中删除，或者新建一个res数组，将不同的元素push到新数组中，返回新数组。效率低，当数组比较长时不合适。 123456789101112let arr = [0, 3, 4, 3, 4, 6, 2, 4];for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1); j--; //要将值重新向前递进 console.log(arr) &#125; &#125;&#125;// [0, 2, 3, 4, 6] 时间复杂度：O(n^2) 使用IndexOf或者includes检查是否重复，其实跟第一种方法比较就是将第二层循环使用了IndexOf这种有遍历接口的API操作，这个操作的本质是不是跟第一种方法一样使用循环遍历，这个就是要看源码了。 12345678910111213141516let arr = [0, 3, 4, 3, 4, 6, 2, 4];let res = [];for (let i = 0, len = arr.length; i &lt; len; i++) &#123; let current= arr[i]; if(res.indexOf(current)===-1)&#123; res.push(current) &#125; //或者使用includes if(!res.includes(current))&#123; res.push(current) &#125;&#125;// [0, 2, 3, 4, 6] 时间复杂度： 先用sort排序，或者已知数组是有序的，后比较相邻两个是否相等。 1234567891011121314let arr = [0, 3, 4, 3, 4, 6, 2, 4];arr.sort();let temp;let res=[]console.log(temp)for (let i = 0, len = arr.length; i &lt; len; i++) &#123; if (!i || temp !== arr[i]) &#123; res.push(arr[i]) &#125; temp=arr[i]&#125;console.log(res);// [0, 2, 3, 4, 6] 时间复杂度：有序数组O(n) ES6中Set属性 1234567// 去除数组的重复成员[...new Set(array)]let arr = [0, 3, 4, 3, 4, 6, 2, 4];let res=[...new Set(arr)]// [0, 2, 3, 4, 6] 注意：1、以上去重只对数组中同一种数据类型进行比较去重，如果有不同的数据类型，要区别对待2、向 Set 加入值的时候，不会发生类型转换，Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，在 Set 内部，它认为两个NaN是相等。3、indexOf内部使用的精确相等运算符（===），NaN===NaN 的结果是 false4、includes内部也是使用的类似精确相等运算符（===），NaN===NaN 的结果是 true 1、单数组操作2、数组遍历方法3、多数组操作","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]},{"title":"README.md","slug":"JS-README","date":"2017-07-05T12:07:40.000Z","updated":"2018-04-05T14:49:33.457Z","comments":true,"path":"2017/07/05/JS-README/","link":"","permalink":"http://yoursite.com/2017/07/05/JS-README/","excerpt":"","text":"本章节主要总结JavaScript中的一些要点。内容比较凌乱， 主要自己总结以及参考大牛的博文。 目录 AJAX过程以及知识体系 同源策略到前端跨域 Array操作方法 JavaScript编程风格 Math对象 Number对象 String对象 this对象 Promise 正则表达式 递归 闭包 日期格式化 一些常用的JS方法 数组排序方法 DOM遍历 用Javascript获取页面元素的位置（client scroll offset等宽度）（转载） Javascript 严格模式详解(转载) JavaScript原型到原型链 JS继承的实现 JS闭包","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}],"keywords":[]}]}