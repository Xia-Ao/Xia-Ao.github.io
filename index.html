<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>夏夏盟主</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="夏夏盟主">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="夏夏盟主">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="夏夏盟主">
  
    <link rel="alternate" href="/atom.xml" title="夏夏盟主" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">夏夏盟主</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">档案</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-Linux下常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/23/Linux-Linux下常用命令/" class="article-date">
  <time datetime="2018-04-22T18:05:40.000Z" itemprop="datePublished">2018-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/23/Linux-Linux下常用命令/">Linux常用命令.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="文件文件夹操作"><a href="#文件文件夹操作" class="headerlink" title="文件文件夹操作"></a>文件文件夹操作</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li><code>cp  [源文件或目录]  [目标文件或目录]</code></li>
<li><p><code>cp /TEST/test1/test01  /TEST/test2</code> 假设复制源文件test1下的test01文件，目标目录为test2</p>
</li>
<li><p><code>cp -r /TEST/test1/.  /TEST/test2</code> 把test1中的文件夹及文件夹中所有文件复制到test2中</p>
</li>
</ul>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul>
<li><code>mv [源文件或目录]  [将要移动到的目录]</code></li>
<li><code>mv  mongo.conf /etc</code> 将mongo.conf文件移动到<code>/etc</code>目录下</li>
<li><code>mv -r  /usr/local/mongodb  /etc</code> 将<code>/usr/local</code>路径下的mongodb文件夹移动到<code>/etc</code>目录下</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li><code>rm file</code> 删除文件</li>
<li><code>rm -r folder</code>  删除文件夹</li>
<li><code>rm -f  file</code> 强制删除</li>
</ul>
<h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><ul>
<li><code>touch file</code> 新建空白文件</li>
<li><code>mkdir folder</code> 在当前目录下生成a目录</li>
</ul>
<h4 id="压缩及解压缩"><a href="#压缩及解压缩" class="headerlink" title="压缩及解压缩"></a>压缩及解压缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br><span class="line">这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</span><br><span class="line"></span><br><span class="line">下面的参数是根据需要在压缩或解压档案时可选的。</span><br><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br><span class="line"></span><br><span class="line">参数-f是必须的</span><br><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tar --cvf jpg.tar *.jpg</code> //将目录里所有jpg文件打包成tar.jpg</li>
<li><code>tar --czf jpg.tar.gz *.jpg</code> //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</li>
<li><code>tar --cjf jpg.tar.bz2 *.jpg</code> //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</li>
<li><code>tar --cZf jpg.tar.Z *.jpg</code> //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</li>
</ul>
<ul>
<li><code>tar --xvf file.tar</code> //解压 tar包</li>
<li><code>tar -xzvf file.tar.gz</code> //解压tar.gz</li>
<li><code>tar -xjvf file.tar.bz2</code> //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Z</li>
</ul>
<ul>
<li><code>tar -tf aaa.tar.gz</code>在不解压的情况下查看压缩包的内容</li>
</ul>
<h4 id="文件读写及权限"><a href="#文件读写及权限" class="headerlink" title="文件读写及权限"></a>文件读写及权限</h4><ul>
<li><code>vim mongo.conf</code> 编辑文件</li>
<li><code>q!</code> 不保存退出</li>
<li><code>qw!</code> 强制保存退出</li>
<li><code>cat mongo.conf</code>  查看文件内容</li>
<li><code>ls -l 文件名</code> 查看linux文件的权限</li>
<li><code>ls -la 文件夹名称（所在目录）</code> 查看linux文件夹的权限</li>
<li><code>ll</code> 查看当前目录下各文件和目录的属性</li>
<li><p><code>sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户） 文件名</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=4 表示可读取，w=2 表示可写入，x=1 表示可执行</span><br><span class="line">若要rwx属性则4+2+1=7；   </span><br><span class="line">若要rw-属性则4+2=6；   </span><br><span class="line">若要r-x属性则4+1=7。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sudo chmod 777 file</code> 每个人都有读和写以及执行的权限</p>
</li>
<li><code></code></li>
<li><code></code></li>
</ul>
<h3 id="端口以及进程状态检查"><a href="#端口以及进程状态检查" class="headerlink" title="端口以及进程状态检查"></a>端口以及进程状态检查</h3><ul>
<li><code>lsof -i:8080</code> 查看8080端口哪个进程在使用</li>
<li><code>netstat -apn|grep mongo</code> 查看mongo进程的端口ip使用</li>
<li><code>ps aux | less</code> : 查看系统中所有进程</li>
<li><code>netstat -apn|grep a</code> 检查a服务的监听等信息</li>
<li><code>telnet xxx.xxx.xxx.xxx</code> port 端口测试</li>
</ul>
<h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ul>
<li><code>history</code> 查看历史执行命令</li>
</ul>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul>
<li><code>ctrl+a</code> 光标快速移动到行首</li>
<li><code>ctrl+e</code> 光标快速移动到行尾</li>
<li><code>ctrl+u</code> 快速删除光标到行首的命令</li>
<li><code>ctrl+k</code> 快速删除光标到行尾的命令</li>
<li><code>按一下Esc，放手在按一次右ctrl</code>，可以调用上次命令的参数</li>
<li><code>lsb_release -a</code> 查看系统版本</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/23/Linux-Linux下常用命令/" data-id="cjgbxbaj300016gjin9t1rsp9" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-SSH连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/22/Linux-SSH连接/" class="article-date">
  <time datetime="2018-04-21T18:05:40.000Z" itemprop="datePublished">2018-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/22/Linux-SSH连接/">本机更换SSH公钥密钥后如何再通过ssh方式登录服务器.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常我们在够买vps的时候，或者第一次配置ssh登录的时候，就会将本机的ssh公钥添加的云平台上去，在初始化vps时，云平台会将添加的ssh公钥添加到用户的<code>/user/.ssh/authorized_keys</code>文件中，例如，如果用户是root用户，则公钥位于<code>/root/.ssh/authorized_keys</code>文件。这样，在vps中具有你本机的公钥，在本机使用下面命令就可以连接，大多数平台都是这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@yourVpsIp</span><br></pre></td></tr></table></figure></p>
<p>但是又一次我作死了，由于谷歌云我使用ssh连接的时候用户弄错了，一直提示我没用次用户的公钥，不知道什么原因，我头脑一热，重新生成了本机的ssh公钥密钥，然后将谷歌云的上的公钥删掉，换成新生成的公钥。之久就怎么也连不上去了，以前使用浏览器的ssh连接方式也连不上了。开始了无尽的作死之路。<br><img src="..\assets\id_rsa.png" alt=""></p>
<p>主要的因为，在vps初始化的时候，将平台的公钥添加的用户的ssh目录下，但是后面如果修改了平台的ssh公钥，vps用户中的<code>authorized_keys</code>并不会同步，只有将<code>authorized_keys</code>内容同步为新的公钥即可。但是谷歌云的话，由于将之前的公钥删除，怎么都连接不上去，都没法操作vps，所以只有重置vps，我选择了关停这台vps，重新购买了一台，将之前的静态IP重新绑定到新的vps。然后顺利连接。</p>
<p>上面的方法比较极端，下面就来介绍一个不用清空vps的方法。</p>
<p>由于我重新生成了本机的ssh公钥密钥，所有我的github，coding平台重新添加ssh公钥就可以了，这个和vps不一样，是可以同步的。但是我的digitalOcean服务器就没有那么好的运气了。也遇到了之前谷歌云一样的问题。登录时提示在vps中没有该用户的公钥。</p>
<p>解决方案：</p>
<p>1、在digitalOcean平台重新添加新的公钥<br><img src="..\assets\id_rsa_9527.png" alt=""><br>2、使用账号密码通过网页版控制台登录。<br><code>cat /root/.ssh/authorized_keys</code>，发现是之前的ssh公钥，并没有的更新，准备手动修改。但是这个网页版做的很不好，没法复制粘贴命令，所以也没法将公钥贴进去，不可能一个一个手敲吧，然后也不能使用上传。这就比较麻烦了将次，后面想到使用文件下载，将文件传输到vps，替换原文件。一开始准备使用百度网盘链接，但是链接地址也是比较长，手敲也不现实，后面想到使用git下载。<br>3、使用git仓库下载。<br>在本地创建一个<code>authorized_keys</code>文件，将公钥复制粘贴进去，然后创建一个git仓库，将<code>authorized_keys</code>文件上传到仓库。然后再vps中安装git <code>apt-get install git</code>,使用git克隆这个仓库到指定的文件路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http://github.com/Xia-Ao/仓库名</span><br></pre></td></tr></table></figure></p>
<p>这样vps就得到了<code>authorized_keys</code>，将root用户下的文件替换掉就可以了。<br>然后使用<code>ssh root@yourVpsIP</code>登录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/22/Linux-SSH连接/" data-id="cjgbxbaj700026gji7jrbnpjk" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/JS-继承/" class="article-date">
  <time datetime="2018-04-05T14:21:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/JS-继承/">JavaScript继承实现的几种方法.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript继承的实现"><a href="#JavaScript继承的实现" class="headerlink" title="JavaScript继承的实现"></a>JavaScript继承的实现</h1><p>继承的实现基于原型链,<a href="JS/js从原型到原型链.md">参考js从原型到原型链</a></p>
<p>下面聊一聊JS继承实现的几种方法：</p>
<p>先定义一个父类Animal，有一个属性，一个实例方法，一个原型方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 初始化一个父类 **/</span></span><br><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>将父类的实例作为子类的原型<code>son.prototype = new father()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1、原型链继承 - 将父类的实例作为子类的原型**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//cat</span></span><br><span class="line">cat.sleep();                        <span class="comment">//cat正在睡觉！</span></span><br><span class="line">cat.eat(<span class="string">'fish'</span>);                    <span class="comment">//cat正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在<code>new Animal()</code>这样的语句之后执行不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的引用属性是所有实例共享的</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<h3 id="2、构造函数继承"><a href="#2、构造函数继承" class="headerlink" title="2、构造函数继承"></a>2、构造函数继承</h3><p>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）<br>这里用到了<code>Animal.call(this);</code>，就是讲Animal的属性和方法等创建到了cat对象里面，但是Animal的原型方法不能创建到cat对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 2、构造函数 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());           <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));       <span class="comment">//报错Uncaught TypeError: cat.eat is not a function</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<h3 id="3、实例继承"><a href="#3、实例继承" class="headerlink" title="3、实例继承"></a>3、实例继承</h3><p>为父类实例添加新特性，作为子类实例返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 3、实例继承 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</span><br><span class="line">    instance.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//jack</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());           <span class="comment">//jack正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));       <span class="comment">//jack正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</li>
</ol>
<p>缺点：</p>
<ol>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ol>
<h3 id="4、拷贝继承"><a href="#4、拷贝继承" class="headerlink" title="4、拷贝继承"></a>4、拷贝继承</h3><p>这是没有什么特点，就是遍历对象，拷贝继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 4、拷贝继承 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        Cat.prototype[p] = animal[p];</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());           <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));       <span class="comment">//Tom正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>支持多继承</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<h3 id="5、组合继承"><a href="#5、组合继承" class="headerlink" title="5、组合继承"></a>5、组合继承</h3><p>结合原型继承和构造函数继承两种方法，通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 5、组合继承 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;  <span class="comment">//要修改函数的执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());           <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));       <span class="comment">//Tom正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<h3 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h3><p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 6、寄生组合继承 **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">    <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    Super.prototype = Animal.prototype;</span><br><span class="line">    <span class="comment">//将实例作为子类的原型</span></span><br><span class="line">    Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());           <span class="comment">//Tom正在睡觉！</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.eat());             <span class="comment">//Tom正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>完美方法，但是复杂。</p>
<h3 id="7、使用ES6中的extends实现继承"><a href="#7、使用ES6中的extends实现继承" class="headerlink" title="7、使用ES6中的extends实现继承"></a>7、使用ES6中的extends实现继承</h3><p>extends继承肯定是最好的继承方法，优先推荐使用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 7、extends继承 **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">        <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">        <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat(food) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'jack'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);              <span class="comment">//jack</span></span><br><span class="line">cat.sleep();                        <span class="comment">//jack正在睡觉！</span></span><br><span class="line">cat.eat(<span class="string">'fish'</span>);                    <span class="comment">//jack正在吃：fish</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在实际应用中。</p>
<p>参考：<a href="http://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">JS实现继承的几种方式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/JS-继承/" data-id="cjgbxbakn001o6gji51i1ujnd" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-README" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/Linux-README/" class="article-date">
  <time datetime="2018-04-05T12:05:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/Linux-README/">readme.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/Linux-README/" data-id="cjgbxbajc00046gji8za2e6ib" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-AJAX使用详细介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/JS-AJAX使用详细介绍/" class="article-date">
  <time datetime="2018-04-05T12:05:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/JS-AJAX使用详细介绍/">Ajax介绍.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于Ajax请求这部分内容，有一篇博文江讲解的十分详细</p>
<h1 id="原文地址：路易斯-Ajax知识体系大梳理"><a href="#原文地址：路易斯-Ajax知识体系大梳理" class="headerlink" title="原文地址：路易斯-Ajax知识体系大梳理"></a>原文地址：<a href="http://louiszhai.github.io/2016/11/02/ajax/#ajax" target="_blank" rel="noopener">路易斯-Ajax知识体系大梳理</a></h1><p>个人总结几个知识点</p>
<h4 id="1、ajax请求，浏览器线程处理过程。"><a href="#1、ajax请求，浏览器线程处理过程。" class="headerlink" title="1、ajax请求，浏览器线程处理过程。"></a>1、ajax请求，浏览器线程处理过程。</h4><p><img src="/assets/import.png" alt=""><br><img src="/assets/import2.png" alt=""></p>
<p>这个过程跨越了解一下浏览器<a href="http://www.cnblogs.com/luleixia/p/6306061.html" target="_blank" rel="noopener">重绘和回流</a></p>
<h4 id="2、XMLHttpRequest属性来源于继承"><a href="#2、XMLHttpRequest属性来源于继承" class="headerlink" title="2、XMLHttpRequest属性来源于继承"></a>2、XMLHttpRequest属性来源于继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr &lt;&lt; XMLHttpRequest.prototype &lt;&lt; XMLHttpRequestEventTarget.prototype &lt;&lt; EventTarget.prototype &lt;&lt; Object.prototype</span><br></pre></td></tr></table></figure>
<h4 id="ajax实例"><a href="#ajax实例" class="headerlink" title="ajax实例"></a>ajax实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xml;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">        xml=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">        xml=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    xml.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((xml.readyState==<span class="number">4</span> &amp;&amp; xml.status==<span class="number">200</span>) || xml.status==<span class="number">304</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xml.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xml.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/ajax_info.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">    xml.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、XMLHttpRequest属性内容"><a href="#3、XMLHttpRequest属性内容" class="headerlink" title="3、XMLHttpRequest属性内容"></a>3、XMLHttpRequest属性内容</h4><p>一个xhr实例对象拥有10个普通属性+9个方法.<br><strong>readyState</strong></p>
<p><img src="/assets/ajax1.png" alt=""></p>
<p><strong>onreadystatechange</strong><br><strong>status</strong><br><strong>statusText</strong><br><strong>onloadstart</strong><br><strong>onprogress</strong><br><strong>onload</strong><br><strong>onloadend</strong><br><strong>timeout</strong><br><strong>ontimeout</strong></p>
<h4 id="4、jquery封装ajax方法"><a href="#4、jquery封装ajax方法" class="headerlink" title="4、jquery封装ajax方法"></a>4、jquery封装ajax方法</h4><p>$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要.</p>
<h4 id="5、Axios"><a href="#5、Axios" class="headerlink" title="5、Axios"></a>5、Axios</h4><ul>
<li>Axios支持node, jquery并不支持.</li>
<li>Axios基于promise语法, jq3.0才开始全面支持.</li>
<li>Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.</li>
<li>vue作者尤大放弃推荐vue-resource, 转向推荐Axios.</li>
</ul>
<h4 id="6、-CORS跨域资源共享"><a href="#6、-CORS跨域资源共享" class="headerlink" title="6、 CORS跨域资源共享"></a>6、 CORS跨域资源共享</h4><p>CORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, <strong>浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应,</strong> 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)<br>CORS请求分为两种, ① 简单请求; ② 非简单请求.</p>
<p>满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客)</p>
<p>1) 请求是以下三种之一:</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>2) http头域不超出以下几种字段:</p>
<ul>
<li>Accept  </li>
<li>Accept-Language  </li>
<li>Content-Language  </li>
<li>Last-Event-ID  </li>
<li>Content-Type字段限三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 Origin 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 Access-Control-_ 等字段.<br>对于非简单请求, 比如Method为POST且Content-Type值为 application/json 的请求或者Method为 PUT 或 DELETE 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 Access-Control-_ 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发).</p>
<h4 id="4、跨越解决方案"><a href="#4、跨越解决方案" class="headerlink" title="4、跨越解决方案"></a>4、跨越解决方案</h4><p>跨域解决方案可以参考另一篇有关<a href="/JS/同源策略到前端跨域.md">同源策略到前端跨域</a>。<br>ajax的跨域主要有CROS、 使用代理、JSONP、webSocket这几种方案，具体的都在上面<a href="/JS/同源策略到前端跨域.md">同源策略到前端跨域</a>。</p>
<h4 id="5、ajax文件上传"><a href="#5、ajax文件上传" class="headerlink" title="5、ajax文件上传"></a>5、ajax文件上传</h4><h4 id="6、ajax请求二进制文件"><a href="#6、ajax请求二进制文件" class="headerlink" title="6、ajax请求二进制文件"></a>6、ajax请求二进制文件</h4><h4 id="7、ajax缓存处理"><a href="#7、ajax缓存处理" class="headerlink" title="7、ajax缓存处理"></a>7、ajax缓存处理</h4><p>js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"If-Modified-Since"</span>,<span class="string">"0"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line"><span class="comment">//或者 URL 参数后加上  "?timestamp=" + new Date().getTime()</span></span><br></pre></td></tr></table></figure>
<p>jquery的http缓存是否开启可通过在settings中指定cache.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url : <span class="string">'url'</span>,</span><br><span class="line">  dataType : <span class="string">"xml"</span>,</span><br><span class="line">  cache: <span class="literal">true</span>,<span class="comment">//true表示缓存开启, false表示缓存不开启</span></span><br><span class="line">  success : <span class="function"><span class="keyword">function</span>(<span class="params">xml, status</span>)</span>&#123;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajaxSetup(&#123;cache:false&#125;); //全局关闭ajax缓存.</span><br></pre></td></tr></table></figure>
<p>除此之外, 调试过程中出现的浏览器缓存尤为可恶. 建议开启隐私浏览器或者勾选☑️控制台的 Disable cache 选项.<br><img src="/assets/ajax22.png" alt=""></p>
<h4 id="8、-ajax错误处理"><a href="#8、-ajax错误处理" class="headerlink" title="8、 ajax错误处理"></a>8、 ajax错误处理</h4><p>前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外)</p>
<p>实际上, $.ajax 方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 $.ajax 的error回调便会触发.</p>
<h4 id="9、ajax调试技巧"><a href="#9、ajax调试技巧" class="headerlink" title="9、ajax调试技巧"></a>9、ajax调试技巧</h4><p>使用node-server配置服务器调试。如何搭建node-server参考他的另一篇<a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="noopener">node-server</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/JS-AJAX使用详细介绍/" data-id="cjgbxbajf00066gjibrp0z2r2" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/JS-闭包/" class="article-date">
  <time datetime="2018-04-05T04:05:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/JS-闭包/">JavaScript闭包.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">阮一峰学习闭包</a></p>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>高程上关于闭包的定义：<strong>闭包是指有权访问另一个函数作用域中的变量的函数</strong></p>
<p>简单理解就是：定义在一个函数内部的函数</p>
<p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>创建闭包的方式：<strong>在一个函数内部创建另一个函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>其中<code>f2( )</code>就是一个闭包能够访问它上一级函数<code>f1()</code>中的变量n。</p>
<p><img src="https://pic4.zhimg.com/v2-88a513ba2ce27b5b41ec6e188d07b30f_r.jpg" alt=""></p>
<p>闭包关于作用域链的图示：</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>1、读取其他函数内部的变量</p>
<p>2、让这些变量的始终保持在内存中，这是一个双刃剑，可以方便的访问内部的变量，即使函数执行完成，其内部变量还保存在内存中可以访问，但是也会带来一系列的问题，外部函数的作用域链和变量对象不能销毁，占用内存。</p>
<p>来看一个典型的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;      </span><br><span class="line">      result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;            </span><br><span class="line">          <span class="built_in">console</span>.log(i);      </span><br><span class="line">      &#125;;     </span><br><span class="line">   &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[<span class="number">6</span>]();  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>从表面上看，似乎每一个函数都返回10 ，但实际上，每个函数都返回10， 因为每个函数的作用域链中都保存着父级函数的活动对象，他们的引用的都是同一个变量i，当父级函数<code>return result</code> 后，变量i的值变成10 ，每个函数引用保存变量i的同一个变量对象，因为此时i=10，所以引用变量指向的值都变成10。</p>
<p>解决这个问题最方便的一个方法是将闭包函数立即执行，每次引用都变成实际i对应的值。每次循环立即执行后销毁引用变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;       </span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       </span><br><span class="line">        <span class="keyword">var</span> c = i;      </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(c);</span><br><span class="line">        &#125;;       </span><br><span class="line">     &#125;();     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[<span class="number">6</span>]();  <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h3 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h3><p>匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window</p>
<p><strong>闭包的this对象一般也是指向window</strong>。具体使用用要看具体的情况，有没有实例化对象，有没有使用apply() call() 等来改变this对象。</p>
<h3 id="面试中问到关于函数闭包的问题"><a href="#面试中问到关于函数闭包的问题" class="headerlink" title="面试中问到关于函数闭包的问题"></a>面试中问到关于函数闭包的问题</h3><p>f(a)(b);</p>
<p>要求返回a+b的结果。</p>
<p>面试的时候面试官写出这样的一个表达式，猛一看这个心想坏了，这是什么表达式，我都没见过，一脸懵逼，一开始以为则是一个立即执行函数，仔细一看不对，这是一个函数执行之后再跟一个<code>()</code>表示执行，还好面试官提示一下，后面的括号就是表示执行函数，那前面的<code>f(a)</code>表示执行结果返回的是一个函数。</p>
<p>接下来就是写这个函数：两种思路，一种我自己想的，一种网上的，当然是晚上的比较好</p>
<h5 id="1、使用闭包"><a href="#1、使用闭包" class="headerlink" title="1、使用闭包"></a>1、使用闭包</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>));  <span class="comment">//返回一个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>)(<span class="number">3</span>));  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>这种方法明显的好，使用闭包，函数里面封装一个函数。最为关键的点在于，<strong>闭包就是能够读取其他函数内部变量的函数</strong>，就相当于把第一次执行时传入的参数x定义为了一个变量，因为在闭包函数中有对x的引用，所以在函数f执行完成之后，内存中x变量的值并没有被清空，在第二次执行的时候可以正常访问到x，并返回x+y。</p>
<p>其实这个问题在<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">阮一峰-关于闭包的学习</a>中有这个表达式，当时自己看的时候只注意到闭包的作用域，没有注意到函数执行表达式。</p>
<h5 id="2、我的方法"><a href="#2、我的方法" class="headerlink" title="2、我的方法"></a>2、我的方法</h5><p>我的方法就比较笨， 将闭包特有的性质单独拿出来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp * <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>));  <span class="comment">//返回一个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>)(<span class="number">3</span>));  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/JS-闭包/" data-id="cjgbxbalu00206gji7815d7w4" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-data-structure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/JS-data-structure/" class="article-date">
  <time datetime="2018-04-05T02:15:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/JS-data-structure/">数据结构之神奇的树.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="/assets/tree.png" alt="">基础的就不说了，可以参考JavaScript数据结构与算法。</p>
<p>树的几个操作几点，<strong><code>root</code>，<code>node.key</code>，<code>node.left</code>， <code>node.right</code></strong>， 树的操作一般都会用到递归调用。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="/assets/tree2.png" alt=""><img src="/assets/tree3.png" alt=""></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p><img src="/assets/tree4.png" alt=""><img src="/assets/tree5.png" alt=""></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><img src="/assets/tree6.png" alt="">后序遍历</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/tree7.png" alt=""></h4><p><img src="/assets/tree8.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/JS-data-structure/" data-id="cjgbxbajv000m6gjitegd3vya" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-DOM遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/05/JS-DOM遍历/" class="article-date">
  <time datetime="2018-04-04T17:05:40.000Z" itemprop="datePublished">2018-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/JS-DOM遍历/">DOM遍历.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DOM遍历"><a href="#DOM遍历" class="headerlink" title="DOM遍历"></a>DOM遍历</h1><p>DOM的遍历分为先序遍历，中序遍历， 后序遍历，是三种不同的顺序的遍历方法</p>
<p>三种方法的区别以及原理请参考：</p>
<p><a href="https://www.jianshu.com/p/456af5480cee" target="_blank" rel="noopener">https://www.jianshu.com/p/456af5480cee</a></p>
<p><a href="http://blog.csdn.net/u013468917/article/details/69556547" target="_blank" rel="noopener">http://blog.csdn.net/u013468917/article/details/69556547</a></p>
<p><strong>先序：</strong>考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p>
<p><strong>中序：</strong>考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p>
<p><strong>后序：</strong>考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</p>
<p>这里只说一下用来遍历的方法：这篇<a href="http://www.cnblogs.com/tracylin/p/5220867.html" target="_blank" rel="noopener">博文</a>写了五种先序遍历的方法，优先使用DOM中提供的两个专门用来遍历的方法。</p>
<p>这两个方法在《JavaScript高程》中有详细的介绍：可以参考第12章12.3</p>
<h2 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h2><p><img src="/assets/traversal1.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用DOM2的"Traversal"模块提供的NodeIterator先序遍历DOM树</span></span><br><span class="line"><span class="comment"> * @param node  根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversalUsingNodeIterator</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(node, NodeFilter.SHOW_ELEMENT,<span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">var</span> node = iterator.nextNode();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.tagName);</span><br><span class="line">        node = iterator.nextNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h2><p>NodeIterator更高级的一个版本，主要使用的<code>nextNode()</code>方法</p>
<p><img src="/assets/traversal2.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用DOM2的"Traversal"模块提供的TreeWalker先序遍历DOM树</span></span><br><span class="line"><span class="comment"> * @param node  根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversalUsingTreeWalker</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> treeWalker = <span class="built_in">document</span>.createTreeWalker(node, NodeFilter.SHOW_ELEMENT,<span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(node &amp;&amp; node.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> node = treeWalker.nextNode();</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.tagName);</span><br><span class="line">        node = treeWalker.nextNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用DOM扩展的Element-Traversal-API，递归遍历DOM树"><a href="#使用DOM扩展的Element-Traversal-API，递归遍历DOM树" class="headerlink" title="使用DOM扩展的Element Traversal API，递归遍历DOM树"></a>使用DOM扩展的Element Traversal API，递归遍历DOM树</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用DOM扩展的Traversal API提供的新的接口先序遍历DOM树</span></span><br><span class="line"><span class="comment"> * @param node 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traversalUsingTraversalAPI</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node &amp;&amp; node.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,len = node.childElementCount, child = node.firstElementChild;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; len ; i++)&#123;</span><br><span class="line">        traversalUsingTraversalAPI(child);</span><br><span class="line">        child = child.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/05/JS-DOM遍历/" data-id="cjgbxbajk000a6gjio075tk1g" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/25/JS-遍历/" class="article-date">
  <time datetime="2018-03-25T14:24:40.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/25/JS-遍历/">JavaScript遍历方法对比以及适用对象.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><h4 id="1、for循环"><a href="#1、for循环" class="headerlink" title="1、for循环"></a>1、for循环</h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>\(<span class="keyword">let</span> i=<span class="number">0</span>; i&amp;lt;length; i++\)&#123; 代码&#125;</span><br></pre></td></tr></table></figure>
<p>说明：因为String对象具有length属性，所以可以直接使用String.length进行遍历</p>
<p>适用对象：<strong>Array，String</strong>，obj没有length，不可以使用for循环</p>
<h4 id="2、for-in"><a href="#2、for-in" class="headerlink" title="2、for in"></a>2、for in</h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> index <span class="keyword">in</span>对象)&#123; 在此执行代码&#125;</span><br></pre></td></tr></table></figure>
<p>说明：for in 遍历的是key值</p>
<p>使用对象：<strong>Array String  Object</strong></p>
<h4 id="3、for-of"><a href="#3、for-of" class="headerlink" title="3、for of"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="noopener">for of</a></h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> 对象)&#123; 在此执行代码&#125;</span><br></pre></td></tr></table></figure>
<p>说明：for of遍历的value值<br>只要具有遍历器接口<strong>Iterator</strong>，都可以使用for of 遍历，比如<strong>NodeList Set Map Array String 类数组</strong></p>
<p>使用对象：<strong>Array String  </strong></p>
<h5 id="for-in-与for-of-区别"><a href="#for-in-与for-of-区别" class="headerlink" title="for in 与for of 区别"></a>for in 与for of 区别</h5><ol>
<li>推荐在循环对象属性的时候，使用<code>for...in</code>,在遍历数组的时候的时候使用<code>for...of</code>。</li>
<li><code>for...in</code>循环出的是key，<code>for...of</code>循环出的是value</li>
<li>注意，<code>for...of</code>是ES6新引入的特性。修复了ES5引入的<code>for...in</code>的不足</li>
<li><code>for...of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li>
</ol>
<h4 id="4、forEach"><a href="#4、forEach" class="headerlink" title="4、forEach"></a>4、forEach</h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br></pre></td></tr></table></figure>
<p>说明：arr当前元素所属的数组对象。</p>
<p>使用对象：<strong>Array</strong> 只有array对象有</p>
<h4 id="其他数组遍历、map-from-filter-some-every等"><a href="#其他数组遍历、map-from-filter-some-every等" class="headerlink" title="其他数组遍历、map from filter some every等"></a>其他数组遍历、map from filter some every等</h4><p>再加上forEach，这些都是针对于<strong>Array</strong>进行遍历的，</p>
<h3 id="String遍历"><a href="#String遍历" class="headerlink" title="String遍历"></a>String遍历</h3><p>一种变换的方法，使用split将字符串切割为字符串数组，再对数组进行遍历。</p>
<h3 id="Object遍历"><a href="#Object遍历" class="headerlink" title="Object遍历"></a>Object遍历</h3><p>除了前面写到的<code>for in</code>遍历Object对象，还有以下几种方法对Object进行遍历</p>
<h4 id="2、Object-keys"><a href="#2、Object-keys" class="headerlink" title="2、Object.keys"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">Object.keys</a></h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">//个表示给定对象的所有可枚举属性的字符串数组。</span></span><br><span class="line"><span class="comment">// 类数组对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).sort()); <span class="comment">// ["0", "1", "2"]</span></span><br></pre></td></tr></table></figure>
<p>说明：Object.keys返回一个由key值组成的<strong>可枚举属性的字符串数组</strong>，再对数组进行遍历既可以遍历Object</p>
<h4 id="3、Object-getOwnPropertyNames"><a href="#3、Object-getOwnPropertyNames" class="headerlink" title="3、Object.getOwnPropertyNames"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noopener">Object.getOwnPropertyNames</a></h4><p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)  <span class="comment">//在给定对象上找到的属性对应的字符串数组。</span></span><br></pre></td></tr></table></figure>
<p>说明：返回一个<strong>数组</strong>，该数组对元素是 obj自身拥有的<strong>枚举或不可枚举属性名称字符串</strong></p>
<h4 id="4、Object-values"><a href="#4、Object-values" class="headerlink" title="4、Object.values()"></a>4、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener">Object.values()</a></h4><p>语法：</p>
<pre><code class="js"><span class="built_in">Object</span>.values(obj)  <span class="comment">//一个包含对象自身的所有可枚举属性值的数组。、</span>
<span class="comment">//示例  随机键值的类数组对象</span>
<span class="keyword">var</span> an_obj = { <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> };
<span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(an_obj)); <span class="comment">// ['b', 'c', 'a']</span>
</code></pre>
<p>说明：Object.values()返回一个<strong>数组</strong>，其元素是在对象上找到的<strong>可枚举属性值</strong>。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p>
<h4 id="5、Object-entries"><a href="#5、Object-entries" class="headerlink" title="5、Object.entries()"></a>5、Object.entries()</h4><p>语法：</p>
<pre><code class="js"><span class="built_in">Object</span>.entries(obj)  <span class="comment">//给定对象自身可枚举属性的键值对数组。</span>
<span class="comment">//示例</span>
<span class="keyword">const</span> obj = { <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> };
<span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['foo', 'bar'], ['baz', 42] ]</span>
</code></pre>
<p>说明：Object.entries()返回一个数组，其元素是与直接在object上找到的<strong>可枚举属性键值对相对应的数组</strong>。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p>
<p>参考：<a href="https://huixisheng.github.io/object-loop/" target="_blank" rel="noopener">JavaScript如何遍历Object</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/25/JS-遍历/" data-id="cjgbxbakp001s6gji0ij1id7x" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-运算符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/25/JS-运算符/" class="article-date">
  <time datetime="2018-03-25T14:22:40.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/25/JS-运算符/">JS数据类型、运算符容易踩的几个坑.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="7种基本数据类型"><a href="#7种基本数据类型" class="headerlink" title="7种基本数据类型"></a>7种基本数据类型</h3><ul>
<li>6种原始类型<ul>
<li><strong>null</strong> 表示缺少的标识，指示变量未指向任何对象。</li>
<li><strong>undefined</strong> 是全局对象的一个属性</li>
<li><strong>Boolean</strong></li>
<li><strong>Number</strong></li>
<li><strong>String</strong></li>
<li><strong>Symbol</strong>（ES6中新定义）</li>
</ul>
</li>
<li><strong>Object</strong></li>
</ul>
<h4 id="另一种区分方式"><a href="#另一种区分方式" class="headerlink" title="另一种区分方式"></a>另一种区分方式</h4><p>1、<strong>值类型</strong>：即5种基本类型（string,number,boolean,null,undefined）；</p>
<p>2、<strong>引用类型</strong>：即数组、函数、对象共三种。这三种类型的处理与值类型会有很大的差别。</p>
<h3 id="JS中常用的内置对象"><a href="#JS中常用的内置对象" class="headerlink" title="JS中常用的内置对象"></a>JS中常用的内置对象</h3><ul>
<li><strong>date</strong>时间对象</li>
<li><strong>string</strong>字符串对象</li>
<li><strong>Math</strong>数学对象，</li>
<li><strong>Number</strong>数值对象，</li>
<li><strong>Array</strong>数组对象，</li>
<li><strong>function</strong>函数对象,</li>
<li><strong>arguments</strong>函数参数集合,</li>
<li><strong>Boolean</strong>布尔对象，</li>
<li><strong>Error</strong>错误对象,</li>
<li><strong>Object</strong>基础对象</li>
</ul>
<p>记住以下结果</p>
<h3 id="null与undefined区别"><a href="#null与undefined区别" class="headerlink" title="null与undefined区别"></a><strong>null与undefined区别</strong></h3><p>javaScript设计者最初是这样设计的：<strong>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN</strong>。</p>
<p>后来在使用的过程中这样区分<br><strong>null表示”没有对象”，即该处不应该有值</strong>。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p>
<p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</strong>。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// object (因为一些以前的原因而不是'null')</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// "undefined"</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span><span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span>  <span class="comment">//true</span></span><br><span class="line">!<span class="literal">undefined</span>  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false    null转化为Number时为0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true  undefined转化为Number时为NaN</span></span><br><span class="line"><span class="number">1</span>+<span class="literal">null</span>  <span class="comment">//1</span></span><br><span class="line"><span class="number">1</span>+<span class="literal">undefined</span>  <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是要记住，null能转化为Number进行计算</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>  <span class="comment">//false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>null与Object</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>==<span class="built_in">Object</span>  <span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span>===<span class="built_in">Object</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[]==![]  <span class="comment">//true</span></span><br><span class="line">[]==<span class="literal">false</span>  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">![]  <span class="comment">//false</span></span><br><span class="line">!&#123;&#125;  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等==="></a>严格相等<code>===</code></h3><p>两个被比较的值在比较前都不进行隐式转换</p>
<h3 id="非严格相等"><a href="#非严格相等" class="headerlink" title="非严格相等 =="></a>非严格相等 <code>==</code></h3><p>在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符<br>=== 的比较方式。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/==.png" alt=""></h4><p>关于</p>
<h4 id="Object-is-A-B"><a href="#Object-is-A-B" class="headerlink" title="Object.is(A,B)"></a>Object.is(A,B)</h4><p>区分和严格相等<code>===</code>之间的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span> , +<span class="number">0</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="number">-0</span> === +<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span> , <span class="literal">NaN</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>] == <span class="string">'1,2'</span>   <span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>] === <span class="string">'1,2'</span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/===.png" alt=""><br><strong>ToNumber</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;&apos;)  // 0</span><br><span class="line">Number(&apos;a123&apos;)  //NaN</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left">result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">+0</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">+0 / 1</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">不转换</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">报错</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">ToNumber(ToPrimitive( input , Number))</td>
</tr>
</tbody>
</table>
<h3 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive()"></a>ToPrimitive()</h3><p>关于隐式转换参考这篇文章：<a href="https://sinaad.github.io/xfe/2016/04/15/ToPrimitive/" target="_blank" rel="noopener">js隐式装箱-ToPrimitive</a></p>
<p>默认用法：ToPrimitive(input [,<br>PreferredType])，（ToPrimitive方法可被修改）</p>
<ul>
<li>如果是Date求原值，则PreferredType是String，其他均为Number。</li>
<li>PreferredType是String，则先调用toString()，结果不是原始值的话再调用valueOf()，还不是原始值的话则抛出错误；</li>
<li>PreferredType是Number，则先调用valueOf()再调用toString()。</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="+ -操作符"></a><code>+ -</code>操作符</h3><p>在加法的过程中，首先把等号左右两边进行了求原值ToPrimitive()操作，然后如果两个原值只要有一个是String类型，就把两个原值都进行转化字符串ToString()操作，进行字符串拼接；否则把两个原值都进行转化数字ToNumber()操作，进行数字相加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+[]  <span class="comment">//0</span></span><br><span class="line">+[<span class="number">0</span>] <span class="comment">//0</span></span><br><span class="line">+&#123;&#125;  <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line">[] + []  <span class="comment">// ""</span></span><br><span class="line"><span class="comment">// PreferredType是Number，则先调用valueOf()再调用toString()。 []==&gt;[]==&gt;""</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; + &#123;&#125;  <span class="comment">//"[object Object][object Object]"</span></span><br><span class="line"><span class="comment">//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;"[object Object]"</span></span><br><span class="line"></span><br><span class="line">[] + &#123;&#125;  <span class="comment">//  "[object Object]"</span></span><br><span class="line"><span class="comment">//[]==&gt;[] ==&gt;""</span></span><br><span class="line"><span class="comment">//&#123;&#125; PreferredType是Number，则先调用valueOf()再调用toString() &#123;&#125;==&gt;&#123;&#125;==&gt;"[object Object]"</span></span><br><span class="line"><span class="comment">// 然后字符串拼接</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; + []  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 原因在于&#123;&#125;在前，被当成&#123;&#125;;直接执行了，变成了 +[],[]的原值是"",+[]需要进行toNumber转换变成了0 ，最后结果为0</span></span><br><span class="line"></span><br><span class="line">++[[ ]][+[ ]]+[+[ ]]</span><br><span class="line"><span class="comment">//这个就有意思了，一开始对[][]理解错了，以为是二维数组，二维数组是name[i][j],这个才是对二维数组的调用，[][]是对前面那个一维数组的调用，数组名就是第一个[].</span></span><br><span class="line">拆分：</span><br><span class="line">&gt;&gt; ++[[]][+[]]   +  [+[]]  很明显 我们知道+[]的结果是<span class="number">0</span></span><br><span class="line">&gt;&gt; ++[[]][<span class="number">0</span>]  +   [<span class="number">0</span>]   这里我们就看到是对数组[[]]的第<span class="number">0</span>位进行操作，即[]</span><br><span class="line">&gt;&gt; ++[]    +  [<span class="number">0</span>]</span><br><span class="line">&gt;&gt; ([]+<span class="number">1</span>)  +  [<span class="number">0</span>]</span><br><span class="line">&gt;&gt; (<span class="string">''</span>+<span class="number">1</span>)  +  [<span class="number">0</span>]</span><br><span class="line">&gt;&gt; <span class="string">'1'</span>     +  [<span class="number">0</span>]</span><br><span class="line">&gt;&gt;<span class="string">'10'</span></span><br></pre></td></tr></table></figure>
<p>下列表达式输出什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">"2"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + +<span class="string">"2"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + -<span class="string">"1"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">"1"</span> + <span class="string">"1"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"A"</span> - <span class="string">"B"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"A"</span> - <span class="string">"B"</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'122'</span></span><br><span class="line"><span class="string">'32'</span></span><br><span class="line"><span class="string">'02'</span></span><br><span class="line"><span class="string">'112'</span></span><br><span class="line"><span class="string">'NaN2'</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure>
<p>运算过程注意一下几点：</p>
<ul>
<li><strong>多个数字和数字字符串混合运算时，跟操作数的位置有关</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> + <span class="number">1</span> + <span class="string">'3'</span>); <span class="comment">// '33'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span> + <span class="number">2</span> + <span class="number">1</span>); <span class="comment">//'321'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字，同样，可以在数字前添加<br>‘’，将数字转为字符串</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'3'</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +<span class="string">'3'</span>); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">3</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="string">''</span>+<span class="number">3</span>)); <span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对于运算结果不能转换成数字的，将返回 NaN</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consol.log(<span class="string">'a'</span> * <span class="string">'sd'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span> - <span class="string">'B'</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="给基本类型数据添加属性，不报错，但取值时是undefined"><a href="#给基本类型数据添加属性，不报错，但取值时是undefined" class="headerlink" title="给基本类型数据添加属性，不报错，但取值时是undefined"></a>给基本类型数据添加属性，不报错，但取值时是undefined</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a.pro = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.pro + a);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.pro = <span class="string">'world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.pro + s);  <span class="comment">//'undefinedhello'</span></span><br></pre></td></tr></table></figure>
<p>a.pro和s.pro都为undefined。给基本类型数据加属性不报错，但是引用的话返回undefined，10+undefined返回NaN，而undefined和string相加时转变成了字符串。</p>
<h3 id="A-amp-amp-B-与-A-B"><a href="#A-amp-amp-B-与-A-B" class="headerlink" title="A &amp;&amp; B 与 A || B"></a>A &amp;&amp; B 与 A || B</h3><p><strong>A &amp;&amp; B</strong><br>与运算，会做boolean转换，当A为false时返回A的结果，当A为true时返回B的结果，<br><strong>A||B</strong> 或运算，当A为true时返回A的结果，当A为false时返回B的结果。</p>
<h3 id="instanceof运算符详解"><a href="#instanceof运算符详解" class="headerlink" title="instanceof运算符详解"></a>instanceof运算符详解</h3><p>这里有一篇<a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html" target="_blank" rel="noopener">博文</a>，详细介绍的instanceof运算符的历史由来以及定义</p>
<p>先说typeof运算符，判断数据类型，对于基本类型，返回基本类型，对于引用类型的，不管哪一种引用类型，都返回’object’</p>
<p>instanceof 运算符通常用来判断一个实例是否属于某种类型，使用方法为<code>foo
instanceof Foo</code>返回一个Boolean值<br>因为这个原因，更多的时候在继承关系中，用来判断<strong>实例是否属于一个父类型</strong>。</p>
<p>instanceof如何实现这样的功能，语言规范里面有详细的介绍，这里截取js表达的方式</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;<span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">     <span class="keyword">var</span> O = R.prototype;<span class="comment">// 取 R 的显示原型</span></span><br><span class="line">     L = L.__proto__;<span class="comment">// 取 L 的隐式原型</span></span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (L === <span class="literal">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (O === L)<span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true </span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         L = L.__proto__;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由规范得到，instanceof将前面表达式的<code>__proto__</code>与后面的表达式的<code>prototype</code>进行严格相等<code>===</code>比较，<br>如果相等返回true，如果不相等，则继续循环获取前面表达式的<code>__proto__</code>，直到 <code>Object.__proto__===null</code>为止返回false。</p>
<p><img src="/assets/prototype.jpg" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">//false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Foo);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/25/JS-运算符/" data-id="cjgbxbako001q6gji2dbkj6u3" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a><span class="tag-list-count">31</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/23/Linux-Linux下常用命令/">Linux常用命令.md</a>
          </li>
        
          <li>
            <a href="/2018/04/22/Linux-SSH连接/">本机更换SSH公钥密钥后如何再通过ssh方式登录服务器.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-继承/">JavaScript继承实现的几种方法.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/Linux-README/">readme.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-AJAX使用详细介绍/">Ajax介绍.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Xia Ao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">档案</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>