<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>夏夏盟主</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="夏夏盟主">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="夏夏盟主">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="夏夏盟主">
  
    <link rel="alternate" href="/atom.xml" title="夏夏盟主" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">夏夏盟主</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">档案</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS-js从原型到原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/05/JS-js从原型到原型链/" class="article-date">
  <time datetime="2018-01-05T05:05:40.000Z" itemprop="datePublished">2018-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/05/JS-js从原型到原型链/">深入理解原型到原型链.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="深入理解原型到原型链"><a href="#深入理解原型到原型链" class="headerlink" title="深入理解原型到原型链"></a>深入理解原型到原型链</h2><p>说到原型，肯定离不开对象，在JS中，关于原型对象，javaScript高级程序设计中写道：</p>
<blockquote>
<p>我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
</blockquote>
<p><img src="/assets/prototype.png" alt=""></p>
<p>上述 图述的代码如下所示，创建一个构造函数，为此构造函数添加prototype属性，person1,person2对象是Person的实例，Person上面的属性和方法共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.syaName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name===person2.name) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//此时执行两次搜索</span></span><br><span class="line">person1.sysName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype1.png" alt=""></h4><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>于是我们更新下关系图：</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype2.png" alt=""></h4><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>此时我们更新关系图：</p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype3.png" alt=""></h4><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>我们在读取对象属性的时候，要注意搜索顺序，</p>
<p><img src="/assets/proto.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.syaName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name=<span class="string">'Mack'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Mack</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时执行两次搜索</span></span><br><span class="line">person1.sysName();  <span class="comment">//"Mack"</span></span><br></pre></td></tr></table></figure>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &apos;Kevin&apos;</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></table></figure>
<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><img src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype4.png" alt=""></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 隐式引用（implicit reference），这个引用称之为 原型（prototype）。进一步，每个原型可以拥有指向自己原型的 隐式引用（即该原型的原型），如此下去，这就是所谓的 原型链（prototype chain）<br>可以在浏览器控制台下一直打印自己的原型，返回的都是一样的。</p>
<p>在javaScripts高级程序设计中，关于原型链是这么定义的：</p>
<p><img src="/assets/chain1.png" alt=""></p>
<p>下面我们看一下书上实现原型链的一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubValue());</span><br></pre></td></tr></table></figure>
<p>例子定义了两个类型：SuperType和SubType，每个类型分别有一个属性和一个方法。它们的主要区别是 SubType 继承了 SuperType ，而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。</p>
<p>关系图如下所示：</p>
<p><img src="/assets/chain2.png" alt=""><br>实际上，所有的引用类型默认都继承了Object，这个继承也是通过原型链实现的。记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.peototype。所以完整的关系如下所示：</p>
<p><img src="/assets/chain3.png" alt=""></p>
<p>关于理解js中原型与原型链，其实主要记住这张图就好了，对象的原型属性指向原型对象，原型对象中又有一个属性constructor又指向这个对象，因为这层关系的存在，所以，才会有原型链，进而有继承，正向来说，因为js语言中要设计继承属性，所以才会设计有这么一层关系，都知道js语言设计参考于C++、java等语言，不知道这些语言中关于继承是怎么设计的，但是js的这种设计一开始我看的很迷糊。</p>
<p>后面再会说一下关于对象原型的一个操作方法</p>
<h2 id="原型操作"><a href="#原型操作" class="headerlink" title="原型操作"></a>原型操作</h2><h3 id="查看原型"><a href="#查看原型" class="headerlink" title="查看原型"></a>查看原型</h3><p>es5带来了查看对象原型的方法——Object.getPrototypeOf，该方法返回指定对象的原型（也就是该对象内部属性[[Prototype]]的值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;))</span><br><span class="line"><span class="comment">//Object.prototype</span></span><br></pre></td></tr></table></figure>
<p>es6带来了另一种查看对象原型的方法——Object.prototype.__proto__，一个对象的__proto__ 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),原型的值可以是一个对象值也可以是null(比如说Object.prototype.<strong>proto</strong>的值就是null)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125;).__proto__</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
<h3 id="创建原型的方式"><a href="#创建原型的方式" class="headerlink" title="创建原型的方式"></a>创建原型的方式</h3><p>在下面的例子中我们将对象a的[[Prototype]]指向b。</p>
<h4 id="使用普通语法创建对象"><a href="#使用普通语法创建对象" class="headerlink" title="使用普通语法创建对象"></a>使用普通语法创建对象</h4><p>这是最容易被大家忽略的方法，在js中你是绕不过原型的，不经意间就创建了原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure>
<p>这种方法无法让a的[[Prototype]]指向b。</p>
<h4 id="使用构造器创建对象"><a href="#使用构造器创建对象" class="headerlink" title="使用构造器创建对象"></a>使用构造器创建对象</h4><p>构造函数就是一个普通的函数，只不过这次不是直接调用函数，而是在函数前加上new关键字。</p>
<p>每个函数都有一个prototype属性，通过new关键字新建的对象的原型会指向构造函数的prototype属性，所以我们可以修改构造函数的prototype属性从而达到操作对象原型的目的。</p>
<p>为了让b继承a，需要有一个构造函数A</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">A.prototype = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a ---&gt; A.prototype === b</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-Object-create-创建对象"><a href="#使用-Object-create-创建对象" class="headerlink" title="使用 Object.create 创建对象"></a>使用 Object.create 创建对象</h4><p>ES5带来了Object.create接口，可以让我们直接设置一个对象原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a ---&gt; b</span></span><br></pre></td></tr></table></figure>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf"></a>Object.setPrototypeOf</h4><p>ES6带来了另一个接口，可以绕过创建对象的过程，直接操作原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a ---&gt; b</span></span><br></pre></td></tr></table></figure>
<h4 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a>proto</h4><p>ES6还带来了一个属性，通过这个属性也可以直接操作原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.__proto__ = b;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a ---&gt; b</span></span><br></pre></td></tr></table></figure>
<p>注意这个属性在ES6规范的附录中，也就意味着不是所有的环境都会有这个属性。</p>
<h4 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 class 关键字</h4><p>ES6引入了以class语法糖，通过extends关键字我们也可以实现继承，但是无法直接操作对象的原型，而是要借助“类”，其实就是构造函数和函数的prototype属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === A.prototype;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a ---&gt; A.prototype === B的实例</span></span><br></pre></td></tr></table></figure>
<h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></p>
<p><a href="http://yanhaijing.com/javascript/2016/07/24/prototype-and-inheritance-of-js/" target="_blank" rel="noopener">详解JavaScript中的原型和继承</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/" target="_blank" rel="noopener">全面理解面向对象的 JavaScript</a></p>
<p>《高程》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/05/JS-js从原型到原型链/" data-id="cjgbxbak2000y6gjihh87jk9j" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-Array操作方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/05/JS-Array操作方法/" class="article-date">
  <time datetime="2017-10-05T12:05:40.000Z" itemprop="datePublished">2017-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/05/JS-Array操作方法/">Array操作方法.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p><a href="http://www.runoob.com/jsref/jsref-constructor-array.html" target="_blank" rel="noopener"><code>constructor</code></a> 返回创建数组对象的原型函数。</p>
<p><a href="http://www.runoob.com/jsref/jsref-length-array.html" target="_blank" rel="noopener"><code>length</code></a><code></code>设置或返回数组元素的个数。</p>
<p><a href="http://www.runoob.com/jsref/jsref-prototype-array.html" target="_blank" rel="noopener"><code>prototype</code></a><code></code>允许你向数组对象添加属性或方法。</p>
<h3 id="Array-对象属性"><a href="#Array-对象属性" class="headerlink" title="Array 对象属性"></a>Array 对象属性</h3><p>改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill</p>
<p>不会改变自身的方法一共有9个，分别为concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes。</p>
<h5 id="添加修改删除等操作"><a href="#添加修改删除等操作" class="headerlink" title="添加修改删除等操作"></a>添加修改删除等操作</h5><p><strong>浅复制</strong> 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象<br><a href="http://www.runoob.com/jsref/jsref-concat-array.html" target="_blank" rel="noopener"><code>concat()</code></a> 连接两个或更多的数组，组成一个新的数组并返回。</p>
<p><a href="http://www.runoob.com/jsref/jsref-copywithin.html" target="_blank" rel="noopener"><code>copyWithin( )</code></a><code></code>从数组的指定位置拷贝元素到数组的另一个指定位置中。</p>
<p><a href="#"><code>slice( start, end )</code></a>将数组中一部分元素<strong>浅复制</strong>存入新的数组对象，并且返回这个数组对象。</p>
<p><a href="#"><code>fill()</code></a>使用一个固定值来填充数组。</p>
<p><a href="#"><code>join()</code></a><code></code>将数组中的所有元素连接成一个字符串，并返回这个字符串。</p>
<p><a href="http://www.runoob.com/jsref/jsref-push.html" target="_blank" rel="noopener"><code>push()</code></a> 向数组的末尾添加一个或更多元素，并返回新的长度，<strong>改变了原数组</strong>。</p>
<p><a href="http://www.runoob.com/jsref/jsref-unshift.html" target="_blank" rel="noopener"><code>unshift()</code></a><code></code>向数组的开头添加一个或更多元素，并返回新的长度。<strong>改变了原数组</strong></p>
<p><a href="http://www.runoob.com/jsref/jsref-shift.html" target="_blank" rel="noopener"><code>shift()</code></a> 删除数组第一个元素，并返回数组的第一个元素，会<strong>改变原数组</strong>。</p>
<p><a href="http://www.runoob.com/jsref/jsref-splice.html" target="_blank" rel="noopener"><code>splice()</code></a> 从数组中添加或删除元素。会<strong>改变原数组</strong></p>
<p><a href="#"><code>pop()</code></a>删除数组的最后一个元素并返回删除后的元素，<strong>改变了原数组</strong>。</p>
<h5 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h5><p><code>copyWithin(ES6)</code>用于数组内元素之间的替换，即替换元素和被替换元素均是数组内的元素。<strong>改变了原数组</strong><br> <code>arr.copyWithin(target, start[, end = this.length])</code></p>
<p><code>fill(ES6)</code>它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。<strong>改变了原数组</strong></p>
<h5 id="查询数组"><a href="#查询数组" class="headerlink" title="查询数组"></a>查询数组</h5><p><a href="http://www.runoob.com/jsref/jsref-every.html" target="_blank" rel="noopener"><code>every()</code></a> 检测数值元素的每个元素是否都符合条件。返回Boolean值。</p>
<p><a href="http://www.runoob.com/jsref/jsref-filter.html" target="_blank" rel="noopener"><code>filter()</code></a> 检测数值元素，并返回符合条件所有元素的数组。</p>
<p><a href="http://www.runoob.com/jsref/jsref-find.html" target="_blank" rel="noopener"><code>find()</code></a> 返回符合传入测试（函数）条件的数组元素。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</p>
<p><a href="#"><code>some()</code></a><code></code>检测数组元素中是否有元素符合指定条件。返回布尔值</p>
<p><a href="http://www.runoob.com/jsref/jsref-findindex.html" target="_blank" rel="noopener"><code>findIndex()</code></a> 返回符合传入测试（函数）条件的数组元素索引。同样，检测到第一个的时候，然后返回，不在执行后面的。</p>
<p><a href="#"><code>indexOf(item,start)</code></a>搜索数组中的元素，并返回它所在的位置，如果没有，返回-1，但是不区分NaN。</p>
<p><a href="#"><code>lastIndexOf()</code></a>返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p>
<p><strong>计算转换</strong></p>
<p><a href="http://www.runoob.com/jsref/jsref-reduce.html" target="_blank" rel="noopener"><code>reduce()</code></a><code></code>将数组元素计算为一个值（从左到右）。如遇到字符串，执行字符串拼接。</p>
<p><a href="http://www.runoob.com/jsref/jsref-reduceright.html" target="_blank" rel="noopener"><code>reduceRight()</code></a><code></code>将数组元素计算为一个值（从右到左）。</p>
<p><a href="http://www.runoob.com/jsref/jsref-tostring-array.html" target="_blank" rel="noopener"><code>toString()</code></a><code></code>把数组转换为字符串，并返回结果。</p>
<p><a href="https://www.gitbook.com/book/xia-ao/notes/edit#" target="_blank" rel="noopener"><code>toLocaleString()</code></a>把数组使用头LocaleString方法转换为字符串，并返回结果。</p>
<p><a href="http://www.runoob.com/jsref/jsref-valueof-array.html" target="_blank" rel="noopener"><code>valueOf()</code></a><code></code>返回数组对象的原始值。</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><a href="#"><code>reverse()</code></a>反转数组的元素顺序，该方法返回对数组的引用，会<strong>改变原数组</strong>。</p>
<p><a href="http://www.runoob.com/jsref/jsref-sort.html" target="_blank" rel="noopener"><code>sort( )</code></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">语法：`arr.sort([comparefn])`comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode\(万国码\)位点顺序排序。</span><br><span class="line"></span><br><span class="line">##### 遍历方法12个</span><br><span class="line"></span><br><span class="line">1、**forEach**</span><br><span class="line"></span><br><span class="line">[`forEach(function(currentValue,index,arr),thisArg)`](http://www.runoob.com/jsref/jsref-foreach.html)  数组每个元素都执行一次回调函数。</span><br><span class="line"></span><br><span class="line">* value 当前正在被处理的元素的值，index 当前元素的数组索引，array 数组本身</span><br><span class="line">* thisArg 可选，用来当做fn函数内的this对象。</span><br><span class="line"></span><br><span class="line">2、**every**</span><br><span class="line"></span><br><span class="line">使用传入的函数测试所有元素，只要其中有一个函数返回值为 false，那么该方法的结果为 false；如果全部返回 true，那么该方法的结果才为 true。</span><br><span class="line"></span><br><span class="line">3、**some**</span><br><span class="line"></span><br><span class="line">some 测试数组元素时，只要有一个函数返回值为 true，则该方法返回 true，若全部返回 false，则该方法返回 false。</span><br><span class="line"></span><br><span class="line">4、**filter**</span><br><span class="line"></span><br><span class="line">filter() 方法使用传入的函数测试所有元素，并**返回所有通过测试的元素组成的新数组**。它就好比一个过滤器，筛掉不符合条件的元素。</span><br><span class="line"></span><br><span class="line">语法：`arr.filter(fn, thisArg)`</span><br><span class="line"></span><br><span class="line">5、**map**</span><br><span class="line"></span><br><span class="line">[`map()`](#)通过指定函数处理数组的每个元素，并返回处理后的**新数组**。</span><br><span class="line"></span><br><span class="line">语法：`arr.map(fn, thisArg)`</span><br><span class="line"></span><br><span class="line">6、**reduce**</span><br><span class="line"></span><br><span class="line">reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。</span><br><span class="line"></span><br><span class="line">语法：`arr.reduce(fn, initialValue)`fn 表示在数组每一项上执行的函数，接受四个参数：</span><br><span class="line">* `previousValue` 上一次调用回调返回的值，或者是提供的初始值</span><br><span class="line">* `value` 数组中当前被处理元素的值</span><br><span class="line">* `index` 当前元素在数组中的索引</span><br><span class="line">* `array` 数组自身</span><br><span class="line"></span><br><span class="line">`initialValue` 指定第一次调用 fn 的第一个参数。</span><br><span class="line">当 fn 第一次执行时：</span><br><span class="line"></span><br><span class="line">* 如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 将等于 initialValue，此时 item 等于数组中的第一个值；</span><br><span class="line">* 如果 initialValue 未被提供，那么 previousVaule 等于数组中的第一个值，item 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</span><br><span class="line">* 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么fn不会被执行，数组的唯一值将被返回。</span><br><span class="line"></span><br><span class="line">7、**reduceRight**</span><br><span class="line"></span><br><span class="line">数组中的每个值（从右至左）开始合并，最终为一个值</span><br><span class="line"></span><br><span class="line">8、**entries(ES6)**</span><br><span class="line"></span><br><span class="line">返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</span><br><span class="line"></span><br><span class="line">9、**find&amp;findIndex(ES6)**</span><br><span class="line"></span><br><span class="line">find() 方法基于ECMAScript 2015（ES6）规范，返回数组中第一个满足条件的元素（如果有的话）， 如果没有，则返回undefined。</span><br><span class="line"></span><br><span class="line">findIndex() 方法也基于ECMAScript 2015（ES6）规范，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。</span><br><span class="line"></span><br><span class="line">语法：`arr.find(fn, thisArg)`，`arr.findIndex(fn, thisArg)`</span><br><span class="line"></span><br><span class="line">10、**keys(ES6)**</span><br><span class="line"></span><br><span class="line">返回一个数组索引的迭代器。</span><br><span class="line"></span><br><span class="line">11、**values(ES6)**</span><br><span class="line"></span><br><span class="line">返回一个数组迭代器对象，该对象包含数组中每个索引的值。</span><br><span class="line"></span><br><span class="line">12、**Symbol.iterator(ES6)**</span><br><span class="line"></span><br><span class="line">###小结：</span><br><span class="line">1. Array.prototype本身就是一个数组，并且它的长度为0。</span><br><span class="line">2. 所有插入元素的方法, 比如 push、unshift，一律返回数组新的长度；</span><br><span class="line">3. 所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组；</span><br><span class="line">4. 部分遍历方法，比如 forEach、every、some、filter、map、find、findIndex，它们都包含function(value,index,array)&#123;&#125; 和 thisArg 这样两个形参。</span><br><span class="line">5. Array.prototype 的所有方法均具有鸭式辨型这种神奇的特性。它们不止可以用来处理数组对象，还可以处理类数组对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Array.of （构造函数）</span><br><span class="line"></span><br><span class="line">`Array.of`用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其它，它基本上与Array构造器功能一致，唯一的区别就在单个数字参数的处理上.</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">Array.of(8.0); // [8]</span><br><span class="line">Array(8.0); // [undefined × 8]</span><br></pre></td></tr></table></figure></p>
<h4 id="Array-from-（构造函数）"><a href="#Array-from-（构造函数）" class="headerlink" title="Array.from （构造函数）"></a>Array.from （构造函数）</h4><p>只要一个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。<br>语法：<code>Array.from(arrayLike[, processingFn[, thisArg]])</code><br>Array.from拥有3个形参，第一个为类似数组的对象，必选。第二个为加工函数，新生成的数组会经过该函数的加工再返回。第三个为this作用域，表示加工函数执行时this的值。后两个参数都是可选的。<br><strong>注意</strong>:一旦使用加工函数，必须明确指定返回值，否则将隐式返回undefined，最终生成的数组也会变成一个只包含若干个undefined元素的空数组。</p>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><p>判定一个对象是数组的五种方法，前四种都不保险，如果将某个对象的对象的<code>__proto__</code>属性为<code>Array.prototype</code>，便导致了该对象继承了Array对象，前四种方法就会判定为true.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="comment">// 1.基于instanceof</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="comment">// 2.基于constructor</span></span><br><span class="line">a.constructor === <span class="built_in">Array</span>;</span><br><span class="line"><span class="comment">// 3.基于Object.prototype.isPrototypeOf</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(a);</span><br><span class="line"><span class="comment">// 4.基于getPrototypeOf</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="comment">// 5.基于Object.prototype.toString</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.apply(a) === <span class="string">'[object Array]'</span>;</span><br></pre></td></tr></table></figure>
<p>所以严格意义上判定一个对象是否是数组，推荐使用第五种方法，再说到<code>Array.isArray()</code>，实际上就是推荐使用的第五种toString方法。</p>
<p>典型问题：</p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>实际上有很多种方法，其实都大同小异，只要熟悉数组操作的API方法，你就可以写出很多种，但是本质都是一样的。优先推荐使用ES6中Set属性不重复的特征去重。</p>
<ol>
<li><p>两层for循环，一层遍历数组，一层循环对比，对相同的元素从数组中删除，或者新建一个res数组，将不同的元素push到新数组中，返回新数组。效率低，当数组比较长时不合适。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">            arr.splice(j, <span class="number">1</span>);</span><br><span class="line">            j--;  <span class="comment">//要将值重新向前递进</span></span><br><span class="line">            <span class="built_in">console</span>.log(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 2, 3, 4, 6]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>时间复杂度：O(n^2)</p>
<ol>
<li><p>使用IndexOf或者includes检查是否重复，其实跟第一种方法比较就是将第二层循环使用了IndexOf这种有遍历接口的API操作，这个操作的本质是不是跟第一种方法一样使用循环遍历，这个就是要看源码了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> current= arr[i];</span><br><span class="line">   <span class="keyword">if</span>(res.indexOf(current)===<span class="number">-1</span>)&#123;</span><br><span class="line">       res.push(current)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//或者使用includes</span></span><br><span class="line">   <span class="keyword">if</span>(!res.includes(current))&#123;</span><br><span class="line">       res.push(current)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 2, 3, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：</p>
</li>
</ol>
<ol>
<li><p>先用<code>sort</code>排序，或者已知数组是有序的，后比较相邻两个是否相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line"><span class="keyword">let</span> res=[]</span><br><span class="line"><span class="built_in">console</span>.log(temp)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!i || temp !== arr[i]) &#123;</span><br><span class="line">        res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    temp=arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 2, 3, 4, 6]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>时间复杂度：有序数组O(n)</p>
<ol>
<li><p>ES6中Set属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> res=[...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 2, 3, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br>1、以上去重只对数组中同一种数据类型进行比较去重，如果有不同的数据类型，要区别对待<br>2、向 Set 加入值的时候，不会发生类型转换，Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，在 Set 内部，它认为两个NaN是相等。<br>3、indexOf内部使用的精确相等运算符（===），<code>NaN===NaN 的结果是 false</code><br>4、includes内部也是使用的类似精确相等运算符（===），<code>NaN===NaN 的结果是 true</code></p>
</li>
</ol>
<h3 id="1、单数组操作"><a href="#1、单数组操作" class="headerlink" title="1、单数组操作"></a>1、单数组操作</h3><h3 id="2、数组遍历方法"><a href="#2、数组遍历方法" class="headerlink" title="2、数组遍历方法"></a>2、数组遍历方法</h3><h3 id="3、多数组操作"><a href="#3、多数组操作" class="headerlink" title="3、多数组操作"></a>3、多数组操作</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/05/JS-Array操作方法/" data-id="cjgbxbaje00056gjivb6iogwd" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-README" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/JS-README/" class="article-date">
  <time datetime="2017-07-05T12:07:40.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/JS-README/">README.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本章节主要总结JavaScript中的一些要点。内容比较凌乱， 主要自己总结以及参考大牛的博文。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="/JS/AJAX使用详细介绍.md">AJAX过程以及知识体系</a></li>
<li><a href="/JS/同源策略到前端跨域.md"><strong>同源策略到前端跨域</strong></a></li>
<li><a href="/JS/Array操作方法.md">Array操作方法</a></li>
<li><a href="/JS/Javascript编程风格.md">JavaScript编程风格</a></li>
<li><a href="/JS/Math对象.md">Math对象</a></li>
<li><a href="/JS/Number对象.md">Number对象</a></li>
<li><a href="/JS/String对象.md">String对象</a></li>
<li><a href="/JS/this对象.md"><strong>this对象</strong></a></li>
<li><a href="/JS/Promise.md"><strong>Promise</strong></a></li>
<li><a href="/JS/正则表达式.md"><strong>正则表达式</strong></a></li>
<li><a href="/JS/递归.md"><strong>递归</strong></a></li>
<li><a href="/JS/闭包.md"><strong>闭包</strong></a></li>
<li><a href="/JS/日期格式化.md">日期格式化</a></li>
<li><a href="/JS/一些常用的JS方法.md">一些常用的JS方法</a></li>
<li><a href="http://www.cnblogs.com/dong-xu/p/7088447.html" target="_blank" rel="noopener">数组排序方法</a></li>
<li><a href="/JS/DOM遍历.md">DOM遍历</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">用Javascript获取页面元素的位置（client scroll offset等宽度）（转载）</a></li>
<li><a href="http://www.zyy1217.com/2017/04/20/Javascript%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Javascript 严格模式详解(转载)</a></li>
<li><a href="/JS/js从原型到原型链.md">JavaScript原型到原型链</a></li>
<li><a href="/JS/继承.md">JS继承的实现</a></li>
<li><a href="/JS/闭包.md">JS闭包</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/05/JS-README/" data-id="cjgbxbajw000o6gji3kyezjui" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a><span class="tag-list-count">31</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/23/Linux-Linux下常用命令/">Linux常用命令.md</a>
          </li>
        
          <li>
            <a href="/2018/04/22/Linux-SSH连接/">本机更换SSH公钥密钥后如何再通过ssh方式登录服务器.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-继承/">JavaScript继承实现的几种方法.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/Linux-README/">readme.md</a>
          </li>
        
          <li>
            <a href="/2018/04/05/JS-AJAX使用详细介绍/">Ajax介绍.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Xia Ao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">档案</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>